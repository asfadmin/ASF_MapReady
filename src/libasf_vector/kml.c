#include "shapefil.h"
#include "asf_vector.h"
#include "asf.h"
#include <assert.h>
#include <ctype.h>
#include "asf_nan.h"
#include "dateUtil.h"
#include "float_image.h"
#include "ceos_io.h"
#include "libasf_proj.h"
#include "ursa.h"
#include <stdio.h>
#include <math.h>

void write_kml_style_keys_ext(FILE *kml_file, c2v_config *cfg);

/*
   When invoking google earth from the command line, you can put a kml
   file as a command line argument, but in that case it wants the kml
   files' location to be fully specified, e.g.:
    googleearth /export/home/user/files/the/dir/here/the_file.kml
*/

const char *altitude_mode()
{
  return "clampToGround";
}

void strip_end_whitesp_inplace(char *s)
{
    char *p = s + strlen(s) - 1;
    while (isspace(*p) && p>s)
        *p-- = '\0';
}

int check_meta_block(const char *block, dbf_header_t *dbf, int nCols)
{
  int ii, visible = FALSE;
  char search[50];

  sprintf(search, "meta.%s", block);
  for (ii=0; ii<nCols; ii++) {
    if (strncmp(dbf[ii].header, search, strlen(search)) == 0 &&
        dbf[ii].visible)
      visible = TRUE;
  }
  return visible;
}

void kml_header(FILE *kml_file)
{
    fprintf(kml_file, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
    fprintf(kml_file,
            "<kml xmlns=\"http://earth.google.com/kml/2.2\">\n");
    fprintf(kml_file, "<Document>\n");
}

static void kml_entry_impl(FILE *kml_file, meta_parameters *meta,
                           char *name, char *png_filename, char *dir,
			   c2v_config *cfg)
{
  dbf_header_t *dbf;
  int ii, kk, nCols;
  int nl = meta->general->line_count;
  int ns = meta->general->sample_count;
  double lat_UL, lon_UL;
  double lat_UR, lon_UR;
  double lat_LL, lon_LL;
  double lat_LR, lon_LR;
  char begin[10], end[10];
  int general_block = FALSE;
  int sar_block = FALSE;
  int optical_block = FALSE;
  int thermal_block = FALSE;
  int transform_block = FALSE;
  int airsar_block = FALSE;
  int stats_block = FALSE;
  int projection_block = FALSE;
  int state_block = FALSE;
  int location_block = FALSE;

  if (meta->location) {
    lat_UL = meta->location->lat_start_near_range;
    lon_UL = meta->location->lon_start_near_range;
    lat_UR = meta->location->lat_start_far_range;
    lon_UR = meta->location->lon_start_far_range;
    lat_LL = meta->location->lat_end_near_range;
    lon_LL = meta->location->lon_end_near_range;
    lat_LR = meta->location->lat_end_far_range;
    lon_LR = meta->location->lon_end_far_range;
  }
  else {
    meta_get_latLon(meta, 0, 0, 0, &lat_UL, &lon_UL);
    meta_get_latLon(meta, nl, 0, 0, &lat_LL, &lon_LL);
    meta_get_latLon(meta, nl, ns, 0, &lat_LR, &lon_LR);
    meta_get_latLon(meta, 0, ns, 0, &lat_UR, &lon_UR);
  }

  // Read configuration file
  if (cfg && strlen(cfg->header_file) > 0) 
    read_header_config_ext("META", &dbf, &nCols, cfg->header_file);
  else
    read_header_config("META", &dbf, &nCols);

  // Print out according to configuration
  fprintf(kml_file, "<Placemark>\n");
  fprintf(kml_file, "  <description><![CDATA[\n");
  fprintf(kml_file, "<table width=\"350\"><tr><td>\n");
  fprintf(kml_file, "<!-- Format: META (generated by %s)-->\n", version_string("convert2vector"));
  for (ii=0; ii<nCols; ii++) {
    if (dbf[ii].visible == 0) {
      strcpy(begin, "<!--");
      strcpy(end, "-->\n");
    }
    else {
      strcpy(begin, "");
      strcpy(end, "\n");
    }
    // General block
    if (check_meta_block("general", dbf, nCols) && !general_block) {
      fprintf(kml_file, "<strong>General</strong><br>\n");
      general_block = TRUE;
    }
    if (strncmp(dbf[ii].header, "meta.general.basename", 21) == 0)
      fprintf(kml_file, "%s<strong>Name</strong>: %s <br>%s",
              begin, meta->general->basename, end);
    else if (strncmp(dbf[ii].header, "meta.general.sensor", 19) == 0)
      fprintf(kml_file, "%s<strong>Sensor</strong>: %s <br>%s",
              begin, meta->general->sensor, end);
    else if (strncmp(dbf[ii].header, "meta.general.sensor_name", 24) == 0)
      fprintf(kml_file, "%s<strong>Sensor name</strong>: %s <br>%s",
              begin, meta->general->sensor_name, end);
    else if (strncmp(dbf[ii].header, "meta.general.mode", 17) == 0)
      fprintf(kml_file, "%s<strong>Mode</strong>: %s <br>%s",
              begin, meta->general->mode, end);
    else if (strncmp(dbf[ii].header, "meta.general.processor", 22) == 0)
      fprintf(kml_file, "%s<strong>Processor</strong>: %s <br>%s",
              begin, meta->general->processor, end);
    else if (strncmp(dbf[ii].header, "meta.general.data_type", 22) == 0) {
      if (meta->general->data_type == ASF_BYTE)
        fprintf(kml_file, "%s<strong>Data type</strong>: BYTE <br>%s",
                begin, end);
      else if (meta->general->data_type == INTEGER16)
        fprintf(kml_file, "%s<strong>Data type</strong>: INTEGER16 <br>%s",
                begin, end);
      else if (meta->general->data_type == INTEGER32)
        fprintf(kml_file, "%s<strong>Data type</strong>: INTEGER32 <br>%s",
                begin, end);
      else if (meta->general->data_type == REAL32)
        fprintf(kml_file, "%s<strong>Data type</strong>: REAL32 <br>%s",
                begin, end);
      else if (meta->general->data_type == REAL64)
        fprintf(kml_file, "%s<strong>Data type</strong>: REAL64 <br>%s",
                begin, end);
      else if (meta->general->data_type == COMPLEX_BYTE)
        fprintf(kml_file, "%s<strong>Data type</strong>: COMPLEX_BYTE <br>%s",
                begin, end);
      else if (meta->general->data_type == COMPLEX_INTEGER16)
        fprintf(kml_file, "%s<strong>Data type</strong>: COMPLEX_INTEGER16 "
                "<br>%s", begin, end);
      else if (meta->general->data_type == COMPLEX_INTEGER32)
        fprintf(kml_file, "%s<strong>Data type</strong>: COMPLEX_INTEGER32 "
                "<br>%s", begin, end);
      else if (meta->general->data_type == COMPLEX_REAL32)
        fprintf(kml_file, "%s<strong>Data type</strong>: COMPLEX_REAL32 "
                "<br>%s", begin, end);
      else if (meta->general->data_type == COMPLEX_REAL64)
        fprintf(kml_file, "%s<strong>Data type</strong>: COMPLEX_REAL64 "
                "<br>%s", begin, end);
    }
    else if (strncmp(dbf[ii].header, "meta.general.image_data_type", 28) == 0) {
      if (meta->general->image_data_type == RAW_IMAGE)
        fprintf(kml_file, "%s<strong>Image data type</strong>: "
                "RAW_IMAGE <br>%s", begin, end);
      else if (meta->general->image_data_type == COMPLEX_IMAGE)
        fprintf(kml_file, "%s<strong>Image data type</strong>: "
                "COMPLEX_IMAGE <br>%s", begin, end);
      else if (meta->general->image_data_type == AMPLITUDE_IMAGE)
        fprintf(kml_file, "%s<strong>Image data type</strong>: "
                "AMPLITUDE_IMAGE <br>%s", begin, end);
      else if (meta->general->image_data_type == PHASE_IMAGE)
        fprintf(kml_file, "%s<strong>Image data type</strong>: "
                "PHASE_IMAGE <br>%s", begin, end);
      else if (meta->general->image_data_type == INTERFEROGRAM)
        fprintf(kml_file, "%s<strong>Image data type</strong>: "
                "INTERFEROGRAM <br>%s", begin, end);
      else if (meta->general->image_data_type == COHERENCE_IMAGE)
        fprintf(kml_file, "%s<strong>Image data type</strong>: "
                "COHERENCE_IMAGE <br>%s", begin, end);
      else if (meta->general->image_data_type == POLARIMETRIC_IMAGE)
	fprintf(kml_file, "%s<strong>Image data type</strong>: "
		"POLARIMETRIC_IMAGE <br>%s", begin, end);
      else if (meta->general->image_data_type == POLARIMETRIC_SEGMENTATION)
        fprintf(kml_file, "%s<strong>Image data type</strong>: "
                "POLARIMETRIC_SEGMENTATION <br>%s", begin, end);
      else if (meta->general->image_data_type == POLARIMETRIC_DECOMPOSITION)
        fprintf(kml_file, "%s<strong>Image data type</strong>: "
                "POLARIMETRIC_DECOMPOSITION <br>%s", begin, end);
      else if (meta->general->image_data_type == POLARIMETRIC_PARAMETER)
        fprintf(kml_file, "%s<strong>Image data type</strong>: "
                "POLARIMETRIC_PARAMETER <br>%s", begin, end);
      else if (meta->general->image_data_type == POLARIMETRIC_C2_MATRIX)
        fprintf(kml_file, "%s<strong>Image data type</strong>: "
                "POLARIMETRIC_C2_MATRIX <br>%s", begin, end);
      else if (meta->general->image_data_type == POLARIMETRIC_C3_MATRIX)
        fprintf(kml_file, "%s<strong>Image data type</strong>: "
                "POLARIMETRIC_C3_MATRIX <br>%s", begin, end);
      else if (meta->general->image_data_type == POLARIMETRIC_C4_MATRIX)
        fprintf(kml_file, "%s<strong>Image data type</strong>: "
                "POLARIMETRIC_C4_MATRIX <br>%s", begin, end);
      else if (meta->general->image_data_type == POLARIMETRIC_T3_MATRIX)
        fprintf(kml_file, "%s<strong>Image data type</strong>: "
                "POLARIMETRIC_T3_MATRIX <br>%s", begin, end);
      else if (meta->general->image_data_type == POLARIMETRIC_T4_MATRIX)
        fprintf(kml_file, "%s<strong>Image data type</strong>: "
                "POLARIMETRIC_T4_MATRIX <br>%s", begin, end);
      else if (meta->general->image_data_type == POLARIMETRIC_STOKES_MATRIX)
        fprintf(kml_file, "%s<strong>Image data type</strong>: "
                "POLARIMETRIC_STOKES_MATRIX <br>%s", begin, end);
      else if (meta->general->image_data_type == LUT_IMAGE)
        fprintf(kml_file, "%s<strong>Image data type</strong>: "
                "LUT_IMAGE <br>%s", begin, end);
      else if (meta->general->image_data_type == ELEVATION)
        fprintf(kml_file, "%s<strong>Image data type</strong>: "
                "ELEVATION <br>%s", begin, end);
      else if (meta->general->image_data_type == DEM)
        fprintf(kml_file, "%s<strong>Image data type</strong>: "
                "DEM <br>%s", begin, end);
      else if (meta->general->image_data_type == IMAGE)
        fprintf(kml_file, "%s<strong>Image data type</strong>: "
                "IMAGE <br>%s", begin, end);
      else if (meta->general->image_data_type == MASK)
        fprintf(kml_file, "%s<strong>Image data type</strong>: "
                  "MASK <br>%s", begin, end);
    }
    else if (strncmp(dbf[ii].header, "meta.general.radiometry", 23) == 0) {
      if (meta->general->radiometry == r_AMP)
        fprintf(kml_file, "%s<strong>Radiometry</strong>: AMPLITUDE <br>%s",
                begin, end);
      else if (meta->general->radiometry == r_SIGMA)
        fprintf(kml_file, "%s<strong>Radiometry</strong>: SIGMA <br>%s",
                begin, end);
      else if (meta->general->radiometry == r_BETA)
        fprintf(kml_file, "%s<strong>Radiometry</strong>: BETA <br>%s",
                begin, end);
      else if (meta->general->radiometry == r_GAMMA)
        fprintf(kml_file, "%s<strong>Radiometry</strong>: GAMMA <br>%s",
                begin, end);
      else if (meta->general->radiometry == r_SIGMA_DB)
        fprintf(kml_file, "%s<strong>Radiometry</strong>: SIGMA_DB <br>%s",
                begin, end);
      else if (meta->general->radiometry == r_BETA_DB)
        fprintf(kml_file, "%s<strong>Radiometry</strong>: BETA_DB <br>%s",
                begin, end);
      else if (meta->general->radiometry == r_GAMMA_DB)
        fprintf(kml_file, "%s<strong>Radiometry</strong>: GAMMA_DB <br>%s",
                begin, end);
      else if (meta->general->radiometry == r_POWER)
        fprintf(kml_file, "%s<strong>Radiometry</strong>: POWER <br>%s",
                begin, end);
    }
    else if (strncmp(dbf[ii].header, "meta.general.acquisition_date", 29) == 0)
      fprintf(kml_file, "%s<strong>Acquisition date</strong>: %s <br>%s",
              begin, meta->general->acquisition_date, end);
    else if (strncmp(dbf[ii].header, "meta.general.orbit_direction", 28) == 0) {
      if (meta->general->orbit_direction == 'A')
        fprintf(kml_file, "%s<strong>Orbit direction</strong>: Ascending "
                "<br>%s", begin, end);
      else
        fprintf(kml_file, "%s<strong>Orbit direction</strong>: Descending "
                "<br>%s", begin, end);
    }
    else if (strncmp(dbf[ii].header, "meta.general.orbit", 18) == 0)
      fprintf(kml_file, "%s<strong>Orbit</strong>: %d <br>%s",
              begin, meta->general->orbit, end);
    else if (strncmp(dbf[ii].header, "meta.general.frame", 18) == 0)
      fprintf(kml_file, "%s<strong>Frame</strong>: %d <br>%s",
              begin, meta->general->frame, end);
    else if (strncmp(dbf[ii].header, "meta.general.band_count", 23) == 0)
      fprintf(kml_file, "%s<strong>Band count</strong>: %d <br>%s",
              begin, meta->general->band_count, end);
    else if (strncmp(dbf[ii].header, "meta.general.bands", 18) == 0)
      fprintf(kml_file, "%s<strong>Bands</strong>: %s <br>%s",
              begin, meta->general->bands, end);
    else if (strncmp(dbf[ii].header, "meta.general.line_count", 23) == 0)
      fprintf(kml_file, "%s<strong>Line count</strong>: %d <br>%s",
              begin, meta->general->line_count, end);
    else if (strncmp(dbf[ii].header, "meta.general.sample_count", 25) == 0)
      fprintf(kml_file, "%s<strong>Sample count</strong>: %d <br>%s",
              begin, meta->general->sample_count, end);
    else if (strncmp(dbf[ii].header, "meta.general.start_line", 23) == 0)
      fprintf(kml_file, "%s<strong>Start line</strong>: %d <br>%s",
              begin, meta->general->start_line, end);
    else if (strncmp(dbf[ii].header, "meta.general.start_sample", 25) == 0)
      fprintf(kml_file, "%s<strong>Start sample</strong>: %d <br>%s",
              begin, meta->general->start_sample, end);
    else if (strncmp(dbf[ii].header, "meta.general.x_pixel_size", 25) == 0)
      fprintf(kml_file, "%s<strong>X pixel size</strong>: %s <br>%s",
              begin, lf(meta->general->x_pixel_size), end);
    else if (strncmp(dbf[ii].header, "meta.general.y_pixel_size", 25) == 0)
      fprintf(kml_file, "%s<strong>Y pixel size</strong>: %s <br>%s",
              begin, lf(meta->general->y_pixel_size), end);
    else if (strncmp(dbf[ii].header, "meta.general.center_latitude", 28) == 0)
      fprintf(kml_file, "%s<strong>Center latitude</strong>: %s <br>%s",
              begin, lf(meta->general->center_latitude), end);
    else if (strncmp(dbf[ii].header, "meta.general.center_longitude", 29) == 0)
      fprintf(kml_file, "%s<strong>Center longitude</strong>: %s <br>%s",
              begin, lf(meta->general->center_longitude), end);
    else if (strncmp(dbf[ii].header, "meta.general.re_major", 21) == 0)
      fprintf(kml_file, "%s<strong>Re major</strong>: %s <br>%s",
              begin, lf(meta->general->re_major), end);
    else if (strncmp(dbf[ii].header, "meta.general.re_minor", 21) == 0)
      fprintf(kml_file, "%s<strong>Re minor</strong>: %s <br>%s",
              begin, lf(meta->general->re_minor), end);
    else if (strncmp(dbf[ii].header, "meta.general.bit_error_rate", 27) == 0)
      fprintf(kml_file, "%s<strong>Bit error rate</strong>: %s <br>%s",
              begin, lf(meta->general->bit_error_rate), end);
    else if (strncmp(dbf[ii].header, "meta.general.missing_lines", 26) == 0)
      fprintf(kml_file, "%s<strong>Missing lines</strong>: %d <br>%s",
              begin, meta->general->missing_lines, end);
    else if (strncmp(dbf[ii].header, "meta.general.no_data", 20) == 0)
      fprintf(kml_file, "%s<strong>No data</strong>: %s <br>%s",
              begin, lf(meta->general->no_data), end);
  }
  for (ii=0; ii<nCols; ii++) {
    if (dbf[ii].visible == 0) {
      strcpy(begin, "<!--");
      strcpy(end, "-->\n");
    }
    else {
      strcpy(begin, "");
      strcpy(end, "\n");
    }
    // SAR block
    if (meta->sar) {
      int kk;
      if (check_meta_block("sar", dbf, nCols) && !sar_block) {
        fprintf(kml_file, "<br><strong>SAR</strong><br>\n");
        sar_block = TRUE;
      }
      if (strncmp(dbf[ii].header, "meta.sar.image_type", 19) == 0)
        fprintf(kml_file, "%s<strong>Image type</strong>: %c <br>%s",
                begin, meta->sar->image_type, end);
      else if (strncmp(dbf[ii].header, "meta.sar.look_direction", 23) == 0)
        fprintf(kml_file, "%s<strong>Look direction</strong>: %c <br>%s",
                begin, meta->sar->look_direction, end);
      else if (strncmp(dbf[ii].header, "meta.sar.azimuth_look_count", 27) == 0)
        fprintf(kml_file, "%s<strong>Azimuth look count</strong>: %d <br>%s",
                begin, meta->sar->azimuth_look_count, end);
      else if (strncmp(dbf[ii].header, "meta.sar.range_look_count", 25) == 0)
        fprintf(kml_file, "%s<strong>Range look count</strong>: %d <br>%s",
                begin, meta->sar->range_look_count, end);
      else if (strncmp(dbf[ii].header, "meta.sar.deskewed", 17) == 0)
        fprintf(kml_file, "%s<strong>Deskewed</strong>: %d <br>%s",
                begin, meta->sar->deskewed, end);
      else if (strncmp(dbf[ii].header, 
		       "meta.sar.original_line_count", 28) == 0)
        fprintf(kml_file, "%s<strong>Original line count</strong>: %d <br>%s",
                begin, meta->sar->original_line_count, end);
      else if (strncmp(dbf[ii].header, 
		       "meta.sar.original_sample_count", 30) == 0)
        fprintf(kml_file, "%s<strong>Original sample count</strong>: %d "
                "<br>%s", begin, meta->sar->original_sample_count, end);
      else if (strncmp(dbf[ii].header, "meta.sar.line_increment", 23) == 0)
        fprintf(kml_file, "%s<strong>Line increment</strong>: %s <br>%s",
                begin, lf(meta->sar->line_increment), end);
      else if (strncmp(dbf[ii].header, "meta.sar.sample_increment", 25) == 0)
        fprintf(kml_file, "%s<strong>Sample increment</strong>: %s <br>%s",
                begin, lf(meta->sar->sample_increment), end);
      else if (strncmp(dbf[ii].header, 
		       "meta.sar.range_time_per_pixel", 29) == 0)
        fprintf(kml_file, "%s<strong>Range time per pixel</strong>: %s <br>%s",
                begin, lf(meta->sar->range_time_per_pixel), end);
      else if (strncmp(dbf[ii].header, 
		       "meta.sar.azimuth_time_per_pixel", 31) == 0)
        fprintf(kml_file, "%s<strong>Azimuth time per pixel</strong>: %s "
                "<br>%s", begin, lf(meta->sar->azimuth_time_per_pixel), end);
      else if (strncmp(dbf[ii].header, "meta.sar.slant_shift", 20) == 0)
        fprintf(kml_file, "%s<strong>Slant shift</strong>: %s <br>%s",
                begin, lf(meta->sar->slant_shift), end);
      else if (strncmp(dbf[ii].header, "meta.sar.time_shift", 19) == 0)
        fprintf(kml_file, "%s<strong>Time shift</strong>: %s <br>%s",
                begin, lf(meta->sar->time_shift), end);
      else if (strncmp(dbf[ii].header, 
		       "meta.sar.slant_range_first_pixel", 32) == 0)
        fprintf(kml_file, "%s<strong>Slant range first pixel</strong>: %s "
                "<br>%s", begin, lf(meta->sar->slant_range_first_pixel), end);
      else if (strncmp(dbf[ii].header, "meta.sar.wavelength", 19) == 0)
        fprintf(kml_file, "%s<strong>Wavelength</strong>: %s <br>%s",
                begin, lf(meta->sar->wavelength), end);
      else if (strncmp(dbf[ii].header, "meta.sar.prf", 12) == 0)
        fprintf(kml_file, "%s<strong>PRF</strong>: %s <br>%s",
                begin, lf(meta->sar->prf), end);
      else if (strncmp(dbf[ii].header, "meta.sar.earth_radius", 21) == 0)
        fprintf(kml_file, "%s<strong>Earth radius</strong>: %s <br>%s",
                begin, lf(meta->sar->earth_radius), end);
      else if (strncmp(dbf[ii].header, "meta.sar.earth_radius_pp", 24) == 0)
        fprintf(kml_file, "%s<strong>Earth radius PP</strong>: %s <br>%s",
                begin, lf(meta->sar->earth_radius_pp), end);
      else if (strncmp(dbf[ii].header, "meta.sar.satellite_height", 25) == 0)
        fprintf(kml_file, "%s<strong>Satellite height</strong>: %s <br>%s",
                begin, lf(meta->sar->satellite_height), end);
      else if (strncmp(dbf[ii].header, 
		       "meta.sar.satellite_binary_time", 30) == 0)
        fprintf(kml_file, "%s<strong>Satellite binary time</strong>: %s "
                "<br>%s", begin, meta->sar->satellite_binary_time, end);
      else if (strncmp(dbf[ii].header, 
		       "meta.sar.satellite_clock_time", 29) == 0)
        fprintf(kml_file, "%s<strong>Satellite clock time</strong>: %s <br>%s",
                begin, meta->sar->satellite_clock_time, end);
      else if (strncmp(dbf[ii].header,
		       "meta.sar.range_doppler_coefficients", 35) == 0) {
        fprintf(kml_file, "%s<strong>Range doppler centroid</strong>: %s "
                "<br>%s", begin, lf(meta->sar->range_doppler_coefficients[0]),
                end);
        fprintf(kml_file, "%s<strong>Range doppler per range pixel</strong>: "
                "%s <br>%s", begin,
                lf(meta->sar->range_doppler_coefficients[1]), end);
        fprintf(kml_file, "%s<strong>Range doppler per range pixel 2</strong>:"
                " %s <br>%s", begin,
                lf(meta->sar->range_doppler_coefficients[2]), end);
      }
      else if (strncmp(dbf[ii].header,
		       "meta.sar.azimuth_doppler_coefficients", 37) == 0) {
        fprintf(kml_file, "%s<strong>Azimuth doppler centroid</strong>: "
                "%s <br>%s", begin,
                lf(meta->sar->azimuth_doppler_coefficients[0]), end);
        fprintf(kml_file, "%s<strong>Azimuth doppler per azimuth pixel"
                "</strong>: %s <br>%s", begin,
                lf(meta->sar->azimuth_doppler_coefficients[1]), end);
        fprintf(kml_file, "%s<strong>Azimuth doppler per azimuth pixel 2"
                "</strong>: %s <br>%s", begin,
                lf(meta->sar->azimuth_doppler_coefficients[2]), end);
      }
      else if (strncmp(dbf[ii].header,
		       "meta.sar.azimuth_processing_bandwidth", 37) == 0)
        fprintf(kml_file, "%s<strong>Azimuth processing bandwidth</strong>: "
                "%s <br>%s", begin ,
                lf(meta->sar->azimuth_processing_bandwidth), end);
      else if (strncmp(dbf[ii].header, "meta.sar.chirp_rate", 19) == 0)
        fprintf(kml_file, "%s<strong>Chirp rate</strong>: %s <br>%s",
                begin, lf(meta->sar->chirp_rate), end);
      else if (strncmp(dbf[ii].header, "meta.sar.pulse_duration", 23) == 0)
        fprintf(kml_file, "%s<strong>Pulse duration</strong>: %s <br>%s",
                begin, lf(meta->sar->pulse_duration), end);
      else if (strncmp(dbf[ii].header, 
		       "meta.sar.range_sampling_rate", 28) == 0)
        fprintf(kml_file, "%s<strong>Range sampling rate</strong>: %s "
                "<br>%s", begin, lf(meta->sar->range_sampling_rate), end);
      else if (strncmp(dbf[ii].header, "meta.sar.polarization", 21) == 0)
        fprintf(kml_file, "%s<strong>Polarization</strong>: %s <br>%s",
                begin, meta->sar->polarization, end);
      else if (strncmp(dbf[ii].header, "meta.sar.multilook", 18) == 0)
        fprintf(kml_file, "%s<strong>Multilook</strong>: %d <br>%s",
                begin, meta->sar->multilook, end);
      else if (strncmp(dbf[ii].header, "meta.sar.pitch", 14) == 0)
        fprintf(kml_file, "%s<strong>Pitch</strong>: %s <br>%s",
                begin, lf(meta->sar->pitch), end);
      else if (strncmp(dbf[ii].header, "meta.sar.roll", 13) == 0)
        fprintf(kml_file, "%s<strong>Roll</strong>: %s <br>%s",
                begin, lf(meta->sar->roll), end);
      else if (strncmp(dbf[ii].header, "meta.sar.yaw", 12) == 0)
        fprintf(kml_file, "%s<strong>Yaw</strong>: %s <br>%s",
                begin, lf(meta->sar->yaw), end);
      else if (strncmp(dbf[ii].header, "meta.transform.incid_a", 24) == 0) {
        for (kk=0; kk<6; kk++)
          fprintf(kml_file, "%s<strong>incid_a(%d)</strong>: %s <br>%s",
                  begin, kk, lf(meta->sar->incid_a[kk]), end);
      }
    }
  }
  for (ii=0; ii<nCols; ii++) {
    if (dbf[ii].visible == 0) {
      strcpy(begin, "<!--");
      strcpy(end, "-->\n");
    }
    else {
      strcpy(begin, "");
      strcpy(end, "\n");
    }
    // Optical block
    if (meta->optical) {
      if (check_meta_block("optical", dbf, nCols) && !optical_block) {
        fprintf(kml_file, "<br><strong>Optical</strong><br>\n");
        optical_block = TRUE;
      }
      if (strncmp(dbf[ii].header, "meta.optical.pointing_direction", 31) == 0)
        fprintf(kml_file, "%s<strong>Pointing direction</strong>: %s <br>%s",
                begin, meta->optical->pointing_direction, end);
      else if (strncmp(dbf[ii].header, 
		       "meta.optical.off_nadir_angle", 28) == 0)
        fprintf(kml_file, "%s<strong>Off nadir angle</strong>: %s <br>%s",
                begin, lf(meta->optical->off_nadir_angle), end);
      else if (strncmp(dbf[ii].header, 
		       "meta.optical.correction_level", 29) == 0)
        fprintf(kml_file, "%s<strong>Correction level</strong>: %s <br>%s",
                begin, meta->optical->correction_level, end);
      else if (strncmp(dbf[ii].header, 
		       "meta.optical.cloud_percentage", 29) == 0)
        fprintf(kml_file, "%s<strong>Cloud percentage</strong>: %s <br>%s",
                begin, lf(meta->optical->cloud_percentage), end);
      else if (strncmp(dbf[ii].header, 
		       "meta.optical.sun_azimuth_angle", 30) == 0)
        fprintf(kml_file, "%s<strong>Sun azimuth angle</strong>: %s <br>%s",
                begin, lf(meta->optical->sun_azimuth_angle), end);
      else if (strncmp(dbf[ii].header, 
		       "meta.optical.sun_elevation_angle", 32) == 0)
        fprintf(kml_file, "%s<strong>Sun elevation angle</strong>: %s <br>%s",
                begin, lf(meta->optical->sun_elevation_angle), end);
    }
  }
  for (ii=0; ii<nCols; ii++) {
    if (dbf[ii].visible == 0) {
      strcpy(begin, "<!--");
      strcpy(end, "-->\n");
    }
    else {
      strcpy(begin, "");
      strcpy(end, "\n");
    }
    // Thermal block
    if (meta->thermal) {
      if (check_meta_block("thermal", dbf, nCols) && !thermal_block) {
        fprintf(kml_file, "<br><strong>Thermal</strong><br>\n");
        thermal_block = TRUE;
      }
      if (strncmp(dbf[ii].header, "meta.thermal.band_gain", 22) == 0)
        fprintf(kml_file, "%s<strong>Band gain</strong>: %s <br>%s",
                begin, lf(meta->thermal->band_gain), end);
      else if (strncmp(dbf[ii].header, 
		       "meta.thermal.band_gain_change", 29) == 0)
        fprintf(kml_file, "%s<strong>Band gain change</strong>: %s <br>%s",
                begin, lf(meta->thermal->band_gain_change), end);
      else if (strncmp(dbf[ii].header, "meta.thermal.day", 16) == 0)
        fprintf(kml_file, "%s<strong>Day</strong>: %d <br>%s",
                begin, meta->thermal->day, end);
    }
  }
  for (ii=0; ii<nCols; ii++) {
    if (dbf[ii].visible == 0) {
      strcpy(begin, "<!--");
      strcpy(end, "-->\n");
    }
    else {
      strcpy(begin, "");
      strcpy(end, "\n");
    }
    // Transform block
    if (meta->transform) {
      if (check_meta_block("transform", dbf, nCols) && !transform_block) {
        fprintf(kml_file, "<br><strong>Transform</strong><br>\n");
        transform_block = TRUE;
      }
      if (strncmp(dbf[ii].header, "meta.transform.parameter_count", 30) == 0)
        fprintf(kml_file, "%s<strong>Parameter count</strong>: %d <br>%s",
                begin, meta->transform->parameter_count, end);
      else if (strncmp(dbf[ii].header, "meta.transform.x", 16) == 0) {
        for (kk=0; kk<meta->transform->parameter_count; kk++)
          fprintf(kml_file, "%s<strong>phi(%d)</strong>: %s <br>%s",
                  begin, kk, lf(meta->transform->x[kk]), end);
      }
      else if (strncmp(dbf[ii].header, "meta.transform.y", 16) == 0) {
        for (kk=0; kk<meta->transform->parameter_count; kk++)
          fprintf(kml_file, "%s<strong>lambda(%d)</strong>: %s <br>%s",
                  begin, kk, lf(meta->transform->y[kk]), end);
      }
      else if (strncmp(dbf[ii].header, "meta.transform.l", 16) == 0) {
        for (kk=0; kk<meta->transform->parameter_count; kk++)
          fprintf(kml_file, "%s<strong>i(%d)</strong>: %s <br>%s",
                  begin, kk, lf(meta->transform->l[kk]), end);
      }
      else if (strncmp(dbf[ii].header, "meta.transform.s", 16) == 0) {
        for (kk=0; kk<meta->transform->parameter_count; kk++)
          fprintf(kml_file, "%s<strong>j(%d)</strong>: %s <br>%s",
                  begin, kk, lf(meta->transform->s[kk]), end);
      }
    }
  }
  for (ii=0; ii<nCols; ii++) {
    if (dbf[ii].visible == 0) {
      strcpy(begin, "<!--");
      strcpy(end, "-->\n");
    }
    else {
      strcpy(begin, "");
      strcpy(end, "\n");
    }
    // AirSAR block
    if (meta->airsar) {
      if (check_meta_block("airsar", dbf, nCols) && !airsar_block) {
        fprintf(kml_file, "<br><strong>AirSAR</strong><br>\n");
        airsar_block = TRUE;
      }
      if (strncmp(dbf[ii].header, "meta.airsar.scale_factor", 24) == 0)
        fprintf(kml_file, "%s<strong>Scale factor</strong>: %s <br>%s",
                begin, lf(meta->airsar->scale_factor), end);
      else if (strncmp(dbf[ii].header, "meta.airsar.gps_altitude", 24) == 0)
        fprintf(kml_file, "%s<strong>GPS altitude</strong>: %s <br>%s",
                begin, lf(meta->airsar->gps_altitude), end);
      else if (strncmp(dbf[ii].header, "meta.airsar.lat_peg_point", 25) == 0)
        fprintf(kml_file, "%s<strong>Lat peg point</strong>: %s <br>%s",
                begin, lf(meta->airsar->lat_peg_point), end);
      else if (strncmp(dbf[ii].header, "meta.airsar.lon_peg_point", 25) == 0)
        fprintf(kml_file, "%s<strong>Lon peg point</strong>: %s <br>%s",
                begin, lf(meta->airsar->lon_peg_point), end);
      else if (strncmp(dbf[ii].header, "meta.airsar.head_peg_point", 26) == 0)
        fprintf(kml_file, "%s<strong>Heading peg point</strong>: %s <br>%s",
                begin, lf(meta->airsar->head_peg_point), end);
      else if (strncmp(dbf[ii].header, 
		       "meta.airsar.along_track_offset", 30) == 0)
        fprintf(kml_file, "%s<strong>Along track offset</strong>: %s <br>%s",
                begin, lf(meta->airsar->along_track_offset), end);
      else if (strncmp(dbf[ii].header, 
		       "meta.airsar.cross_track_offset", 30) == 0)
        fprintf(kml_file, "%s<strong>Cross track offset</strong>: %s <br>%s",
                begin, lf(meta->airsar->cross_track_offset), end);
    }
  }
  for (ii=0; ii<nCols; ii++) {
    if (dbf[ii].visible == 0) {
      strcpy(begin, "<!--");
      strcpy(end, "-->\n");
    }
    else {
      strcpy(begin, "");
      strcpy(end, "\n");
    }
    // Projection block
    if (meta->projection) {
      if (check_meta_block("projection", dbf, nCols) && !projection_block) {
        fprintf(kml_file, "<br><strong>Projection</strong><br>\n");
        projection_block = TRUE;
      }
      if (strncmp(dbf[ii].header, "meta.projection.type", 20) == 0) {
        if (meta->projection->type == UNIVERSAL_TRANSVERSE_MERCATOR)
          fprintf(kml_file, "%s<strong>Type</strong>: "
                  "UNIVERSAL_TRANSVERSE_MERCATOR <br>%s", begin, end);
        else if (meta->projection->type == POLAR_STEREOGRAPHIC)
          fprintf(kml_file, "%s<strong>Type</strong>: "
                  "POLAR_STEREOGRAPHIC <br>%s", begin, end);
        else if (meta->projection->type == ALBERS_EQUAL_AREA)
          fprintf(kml_file, "%s<strong>Type</strong>: "
                  "ALBERS_EQUAL_AREA <br>%s", begin, end);
        else if (meta->projection->type == LAMBERT_CONFORMAL_CONIC)
          fprintf(kml_file, "%s<strong>Type</strong>: "
                  "LAMBERT_CONFORMAL_CONIC <br>%s", begin, end);
        else if (meta->projection->type == LAMBERT_AZIMUTHAL_EQUAL_AREA)
          fprintf(kml_file, "%s<strong>Type</strong>: "
                  "LAMBERT_AZIMUTHAL_EQUAL_AREA<br>%s", begin, end);
        else if (meta->projection->type == STATE_PLANE)
          fprintf(kml_file, "%s<strong>Type</strong>: "
                  "STATE_PLANE <br>%s", begin, end);
        else if (meta->projection->type == SCANSAR_PROJECTION)
          fprintf(kml_file, "%s<strong>Type</strong>: "
                  "SCANSAR_PROJECTION <br>%s", begin, end);
        else if (meta->projection->type == LAT_LONG_PSEUDO_PROJECTION)
          fprintf(kml_file, "%s<strong>Type</strong>: "
                  "LAT_LONG_PSEUDO_PROJECTION <br>%s", begin, end);
        else if (meta->projection->type == UNKNOWN_PROJECTION)
          fprintf(kml_file, "%s<strong>Type</strong>: "
                  "UNKNOWN_PROJECTION <br>%s", begin, end);
      }
      else if (strncmp(dbf[ii].header, "meta.projection.startX", 22) == 0)
        fprintf(kml_file, "%s<strong>StartX</strong>: %s <br>%s",
                begin, lf(meta->projection->startX), end);
      else if (strncmp(dbf[ii].header, "meta.projection.startY", 22) == 0)
        fprintf(kml_file, "%s<strong>StartY</strong>: %s <br>%s",
                begin, lf(meta->projection->startY), end);
      else if (strncmp(dbf[ii].header, "meta.projection.perX", 20) == 0)
        fprintf(kml_file, "%s<strong>PerX</strong>: %s <br>%s",
                begin, lf(meta->projection->perX), end);
      else if (strncmp(dbf[ii].header, "meta.projection.perY", 20) == 0)
        fprintf(kml_file, "%s<strong>PerY</strong>: %s <br>%s",
                begin, lf(meta->projection->perY), end);
      else if (strncmp(dbf[ii].header, "meta.projection.units", 21) == 0)
        fprintf(kml_file, "%s<strong>Units</strong>: %s <br>%s",
                begin, meta->projection->units, end);
      else if (strncmp(dbf[ii].header, "meta.projection.hem", 19) == 0) {
        if (meta->projection->hem == 'N')
          fprintf(kml_file, "%s<strong>Hemisphere</strong>: North <br>%s",
                  begin, end);
        else if (meta->projection->hem == 'S')
          fprintf(kml_file, "%s<strong>Hemisphere</strong>: South <br>%s",
                  begin, end);
      }
      else if (strncmp(dbf[ii].header, "meta.projection.spheroid", 24) == 0) {
        if (meta->projection->spheroid == BESSEL_SPHEROID)
          fprintf(kml_file, "%s<strong>Spheroid</strong>: BESSEL <br>%s",
                  begin, end);
        else if (meta->projection->spheroid == CLARKE1866_SPHEROID)
          fprintf(kml_file, "%s<strong>Spheroid</strong>: CLARKE1866 <br>%s",
                  begin, end);
        else if (meta->projection->spheroid == CLARKE1880_SPHEROID)
          fprintf(kml_file, "%s<strong>Spheroid</strong>: CLARKE1880 <br>%s",
                  begin, end);
        else if (meta->projection->spheroid == GEM6_SPHEROID)
          fprintf(kml_file, "%s<strong>Spheroid</strong>: GEM6 <br>%s",
                  begin, end);
        else if (meta->projection->spheroid == GEM10C_SPHEROID)
          fprintf(kml_file, "%s<strong>Spheroid</strong>: GEM10C <br>%s",
                  begin, end);
        else if (meta->projection->spheroid == GRS1980_SPHEROID)
          fprintf(kml_file, "%s<strong>Spheroid</strong>: GRS1980 <br>%s",
                  begin, end);
        else if (meta->projection->spheroid == INTERNATIONAL1924_SPHEROID)
          fprintf(kml_file, "%s<strong>Spheroid</strong>: INTERNATIONAL1924 "
                  "<br>%s", begin, end);
        else if (meta->projection->spheroid == INTERNATIONAL1967_SPHEROID)
          fprintf(kml_file, "%s<strong>Spheroid</strong>: INTERNATIONAL1967 "
                  "<br>%s", begin, end);
        else if (meta->projection->spheroid == WGS72_SPHEROID)
          fprintf(kml_file, "%s<strong>Spheroid</strong>: WGS72 <br>%s",
                  begin, end);
        else if (meta->projection->spheroid == WGS84_SPHEROID)
          fprintf(kml_file, "%s<strong>Spheroid</strong>: WGS84 <br>%s",
                  begin, end);
        else if (meta->projection->spheroid == HUGHES_SPHEROID)
          fprintf(kml_file, "%s<strong>Spheroid</strong>: HUGHES <br>%s",
                  begin, end);
        else
          fprintf(kml_file, "%s<strong>Spheroid</strong>: UNKNOWN <br>%s",
                  begin, end);
      }
      else if (strncmp(dbf[ii].header, "meta.projection.re_major", 24) == 0)
        fprintf(kml_file, "%s<strong>re major</strong>: %s <br>%s",
                begin, lf(meta->projection->re_major), end);
      else if (strncmp(dbf[ii].header, "meta.projection.re_minor", 24) == 0)
        fprintf(kml_file, "%s<strong>re minor</strong>: %s <br>%s",
                begin, lf(meta->projection->re_minor), end);
      else if (strncmp(dbf[ii].header, "meta.projection.datum", 21) == 0) {
        if (meta->projection->datum == EGM96_DATUM)
          fprintf(kml_file, "%s<strong>Datum</strong>: EGM96 <br>%s",
                  begin, end);
        else if (meta->projection->datum == ED50_DATUM)
          fprintf(kml_file, "%s<strong>Datum</strong>: ED50 <br>%s",
                  begin, end);
        else if (meta->projection->datum == ETRF89_DATUM)
          fprintf(kml_file, "%s<strong>Datum</strong>: ETRF89 <br>%s",
                  begin, end);
        else if (meta->projection->datum == ETRS89_DATUM)
          fprintf(kml_file, "%s<strong>Datum</strong>: ETRS89 <br>%s",
                  begin, end);
        else if (meta->projection->datum == ITRF97_DATUM)
          fprintf(kml_file, "%s<strong>Datum</strong>: ITRF97 <br>%s",
                  begin, end);
        else if (meta->projection->datum == NAD27_DATUM)
          fprintf(kml_file, "%s<strong>Datum</strong>: NAD27 <br>%s",
                  begin, end);
        else if (meta->projection->datum == NAD83_DATUM)
          fprintf(kml_file, "%s<strong>Datum</strong>: NAD83 <br>%s",
                  begin, end);
        else if (meta->projection->datum == WGS72_DATUM)
          fprintf(kml_file, "%s<strong>Datum</strong>: WGS72 <br>%s",
                  begin, end);
        else if (meta->projection->datum == WGS84_DATUM)
          fprintf(kml_file, "%s<strong>Datum</strong>: WGS84 <br>%s",
                  begin, end);
        else if (meta->projection->datum == HUGHES_DATUM)
          fprintf(kml_file, "%s<strong>Datum</strong>: HUGHES <br>%s",
                  begin, end);
        else
          fprintf(kml_file, "%s<strong>Datum</strong>: UNKNOWN <br>%s",
                  begin, end);
      }
      else if (strncmp(dbf[ii].header, "meta.projection.height", 22) == 0)
        fprintf(kml_file, "%s<strong>Height</strong>: %s <br>%s",
                begin, lf(meta->projection->height), end);
      if (meta->projection->type == ALBERS_EQUAL_AREA) {
        if (strncmp(dbf[ii].header,
		    "meta.projection.param.albers.std_parallel1", 42) == 0)
          fprintf(kml_file, "%s<strong>First standard parallel</strong>: "
                  "%s <br>%s", begin,
                  lf(meta->projection->param.albers.std_parallel1), end);
        else if (strncmp(dbf[ii].header,
			 "meta.projection.param.albers.std_parallel2", 
			 43) == 0)
          fprintf(kml_file, "%s<strong>Second standard parallel</strong>: "
                  "%s <br>%s", begin,
                  lf(meta->projection->param.albers.std_parallel2), end);
        else if (strncmp(dbf[ii].header,
			 "meta.projection.param.albers.center_meridian", 
			 45) == 0)
          fprintf(kml_file, "%s<strong>Center meridian</strong>: "
                  "%s <br>%s", begin,
                  lf(meta->projection->param.albers.center_meridian), end);
        else if (strncmp(dbf[ii].header,
			 "meta.projection.param.albers.orig_latitude", 
			 43) == 0)
          fprintf(kml_file, "%s<strong>Latitude of origin</strong>: "
                  "%s <br>%s", begin,
                  lf(meta->projection->param.albers.orig_latitude), end);
        else if (strncmp(dbf[ii].header,
			 "meta.projection.param.albers.false_easting", 
			 43) == 0)
          fprintf(kml_file, "%s<strong>False easting</strong>: "
                  "%s <br>%s", begin,
                  lf(meta->projection->param.albers.false_easting), end);
        else if (strncmp(dbf[ii].header,
			 "meta.projection.param.albers.false_northing", 
			 44) == 0)
          fprintf(kml_file, "%s<strong>False northing</strong>: %s<br>%s",
                  begin, lf(meta->projection->param.albers.false_northing),
                  end);
      }
      else if (meta->projection->type == SCANSAR_PROJECTION) {
        if (strncmp(dbf[ii].header, 
		    "meta.projection.param.atct.rlocal", 33) == 0)
          fprintf(kml_file, "%s<strong>rlocal</strong>: %s <br>%s",
                  begin, lf(meta->projection->param.atct.rlocal), end);
        else if (strncmp(dbf[ii].header,
			 "meta.projection.param.atct.alpha1", 33) == 0)
          fprintf(kml_file, "%s<strong>alpha 1</strong>: %s <br>%s",
                  begin, lf(meta->projection->param.atct.alpha1), end);
        else if (strncmp(dbf[ii].header,
			 "meta.projection.param.atct.alpha2", 33) == 0)
          fprintf(kml_file, "%s<strong>alpha 2</strong>: %s <br>%s",
                  begin, lf(meta->projection->param.atct.alpha2), end);
        else if (strncmp(dbf[ii].header,
			 "meta.projection.param.atct.alpha3", 33) == 0)
          fprintf(kml_file, "%s<strong>alpha 3</strong>: %s <br>%s",
                  begin, lf(meta->projection->param.atct.alpha3), end);
      }
      else if (meta->projection->type == LAMBERT_AZIMUTHAL_EQUAL_AREA) {
        if (strncmp(dbf[ii].header,
		    "meta.projection.param.lamaz.center_lat", 38) == 0)
          fprintf(kml_file, "%s<strong>Center latitude</strong>: %s <br>%s",
                  begin, lf(meta->projection->param.lamaz.center_lat), end);
        else if (strncmp(dbf[ii].header,
			 "meta.projection.param.lamaz.center_lon", 38) == 0)
          fprintf(kml_file, "%s<strong>Center longitude</strong>: %s <br>%s",
                  begin, lf(meta->projection->param.lamaz.center_lon), end);
        else if (strncmp(dbf[ii].header,
			 "meta.projection.param.lamaz.false_easting", 41) == 0)
          fprintf(kml_file, "%s<strong>False easting</strong>: %s <br>%s",
                  begin, lf(meta->projection->param.lamaz.false_easting), end);
        else if (strncmp(dbf[ii].header,
			 "meta.projection.param.lamaz.false_northing", 
			 42) == 0)
          fprintf(kml_file, "%s<strong>False northing</strong>: %s <br>%s",
                  begin, lf(meta->projection->param.lamaz.false_northing),
                  end);
      }
      else if (meta->projection->type == LAMBERT_CONFORMAL_CONIC) {
        if (strncmp(dbf[ii].header, 
		    "meta.projection.param.lamcc.plat1", 33) == 0)
          fprintf(kml_file, "%s<strong>First standard parallel</strong>: %s "
                  "<br>%s", begin, lf(meta->projection->param.lamcc.plat1),
                  end);
        else if (strncmp(dbf[ii].header,
			 "meta.projection.param.lamcc.plat2", 33) == 0)
          fprintf(kml_file, "%s<strong>Second standard parallel</strong>: %s "
                  "<br>%s", begin, lf(meta->projection->param.lamcc.plat2),
                  end);
        else if (strncmp(dbf[ii].header,
			 "meta.projection.param.lamcc.lat0", 32) == 0)
          fprintf(kml_file, "%s<strong>Original latitude</strong>: %s <br>%s",
                  begin, lf(meta->projection->param.lamcc.lat0), end);
        else if (strncmp(dbf[ii].header,
			 "meta.projection.param.lamcc.lon0", 32) == 0)
          fprintf(kml_file, "%s<strong>Original longitude</strong>: %s <br>%s",
                  begin, lf(meta->projection->param.lamcc.lon0), end);
        else if (strncmp(dbf[ii].header,
			 "meta.projection.param.lamcc.false_easting", 41) == 0)
          fprintf(kml_file, "%s<strong>False easting</strong>: %s <br>%s",
                  begin, lf(meta->projection->param.lamcc.false_easting), end);
        else if (strncmp(dbf[ii].header,
			 "meta.projection.param.lamcc.false_northing", 
			 42) == 0)
          fprintf(kml_file, "%s<strong>False northing</strong>: %s <br>%s",
                  begin, lf(meta->projection->param.lamcc.false_northing),
                  end);
        else if (strncmp(dbf[ii].header,
			 "meta.projection.param.lamcc.scale_factor", 40) == 0)
          fprintf(kml_file, "%s<strong>Scale factor</strong>: %s <br>%s",
                  begin, lf(meta->projection->param.lamcc.scale_factor), end);
      }
      else if (meta->projection->type == POLAR_STEREOGRAPHIC) {
        if (strncmp(dbf[ii].header, "meta.projection.param.ps.slat", 29) == 0)
          fprintf(kml_file, "%s<strong>Reference latitude</strong>: %s <br>%s",
                  begin, lf(meta->projection->param.ps.slat), end);
        else if (strncmp(dbf[ii].header,
			 "meta.projection.param.ps.slon", 29) == 0)
          fprintf(kml_file, "%s<strong>Reference longitude</strong>: %s "
                  "<br>%s", begin, lf(meta->projection->param.ps.slon), end);
        else if (strncmp(dbf[ii].header,
			 "meta.projection.param.ps.false_easting", 38) == 0)
          fprintf(kml_file, "%s<strong>False easting</strong>: %s <br>%s",
                  begin, lf(meta->projection->param.ps.false_easting), end);
        else if (strncmp(dbf[ii].header,
			 "meta.projection.param.ps.false_northing", 39) == 0)
          fprintf(kml_file, "%s<strong>False northing</strong>: %s <br>%s",
                  begin, lf(meta->projection->param.ps.false_northing), end);
      }
      else if (meta->projection->type == UNIVERSAL_TRANSVERSE_MERCATOR) {
        if (strncmp(dbf[ii].header, "meta.projection.param.utm.zone", 30) == 0)
          fprintf(kml_file, "%s<strong>Zone</strong>: %d <br>%s",
                  begin, meta->projection->param.utm.zone, end);
        else if (strncmp(dbf[ii].header,
			 "meta.projection.param.utm.false_easting", 39) == 0)
          fprintf(kml_file, "%s<strong>False easting</strong>: %s <br>%s",
                  begin, lf(meta->projection->param.utm.false_easting), end);
        else if (strncmp(dbf[ii].header,
			 "meta.projection.param.utm.false_northing", 40) == 0)
          fprintf(kml_file, "%s<strong>False northing</strong>: %s <br>%s",
                  begin, lf(meta->projection->param.utm.false_northing), end);
        else if (strncmp(dbf[ii].header,
			 "meta.projection.param.utm.lat0", 30) == 0)
          fprintf(kml_file, "%s<strong>Latitude</strong>: %s <br>%s",
                  begin, lf(meta->projection->param.utm.lat0), end);
        else if (strncmp(dbf[ii].header,
			 "meta.projection.param.utm.lon0", 30) == 0)
          fprintf(kml_file, "%s<strong>Longitude</strong>: %s <br>%s",
                  begin, lf(meta->projection->param.utm.lon0), end);
        else if (strncmp(dbf[ii].header,
			 "meta.projection.param.utm.scale_factor", 38) == 0)
          fprintf(kml_file, "%s<strong>Scale factor</strong>: %s <br>%s",
                  begin, lf(meta->projection->param.utm.scale_factor), end);
      }
      else if (meta->projection->type == STATE_PLANE) {
        if (strncmp(dbf[ii].header, 
		    "meta.projection.param.state.zone", 32) == 0)
          fprintf(kml_file, "%s<strong>Zone</strong>: %d <br>%s",
                  begin, meta->projection->param.state.zone, end);
      }
    }
  }
  for (ii=0; ii<nCols; ii++) {
    if (dbf[ii].visible == 0) {
      strcpy(begin, "<!--");
      strcpy(end, "-->\n");
    }
    else {
      strcpy(begin, "");
      strcpy(end, "\n");
    }
    // Stats block
    if (meta->stats) {
      if (check_meta_block("stats", dbf, nCols) && !stats_block) {
        fprintf(kml_file, "<br><strong>Statistics</strong><br>\n");
        stats_block = TRUE;
      }
      if (strncmp(dbf[ii].header, "meta.stats.band_count", 21) == 0)
        fprintf(kml_file, "%s<strong>Band count</strong>: %d <br>%s", begin,
                meta->stats->band_count, end);
      for (kk=0; kk<meta->stats->band_count; kk++) {
        if (strncmp(dbf[ii].header, "meta.stats.band_stats.band_id", 29) == 0)
          fprintf(kml_file, "%s<strong>Band ID</strong>: %s <br>%s", begin,
                  meta->stats->band_stats[kk].band_id, end);
        if (strncmp(dbf[ii].header, "meta.stats.band_stats.min", 25) == 0)
          fprintf(kml_file, "%s<strong>Minimum value</strong>: %s <br>%s",
                  begin, lf(meta->stats->band_stats[kk].min), end);
        if (strncmp(dbf[ii].header, "meta.stats.band_stats.max", 25) == 0)
          fprintf(kml_file, "%s<strong>Maximum value</strong>: %s <br>%s",
                  begin, lf(meta->stats->band_stats[kk].max), end);
        if (strncmp(dbf[ii].header, "meta.stats.band_stats.mean", 26) == 0)
          fprintf(kml_file, "%s<strong>Mean value</strong>: %s <br>%s",
                  begin, lf(meta->stats->band_stats[kk].mean), end);
        if (strncmp(dbf[ii].header, "meta.stats.band_stats.rmse", 26) == 0)
          fprintf(kml_file, "%s<strong>Root mean square error</strong>: "
                  "%s<br>%s", begin, lf(meta->stats->band_stats[kk].rmse),
                  end);
        if (strncmp(dbf[ii].header,
		    "meta.stats.band_stats.std_deviation", 35) == 0)
          fprintf(kml_file, "%s<strong>Standard deviation</strong>: %s <br>%s",
                  begin, lf(meta->stats->band_stats[kk].std_deviation), end);
        if (strncmp(dbf[ii].header, "meta.stats.band_stats.mask", 26) == 0)
          fprintf(kml_file, "%s<strong>Mask value</strong>: %s <br>%s",
                  begin, lf(meta->stats->band_stats[kk].mask), end);
      }
    }
  }
  for (ii=0; ii<nCols; ii++) {
    if (dbf[ii].visible == 0) {
      strcpy(begin, "<!--");
      strcpy(end, "-->\n");
    }
    else {
      strcpy(begin, "");
      strcpy(end, "\n");
    }
    // State vector block
    if (meta->state_vectors) {
      if (check_meta_block("state", dbf, nCols) && !state_block) {
        fprintf(kml_file, "<br><strong>State vectors</strong><br>\n");
        state_block = TRUE;
      }
      if (strncmp(dbf[ii].header, "meta.state.year", 15) == 0)
        fprintf(kml_file, "%s<strong>Year of image start</strong>: %d <br>%s",
                begin, meta->state_vectors->year, end);
      else if (strncmp(dbf[ii].header, "meta.state.julDay", 17) == 0)
        fprintf(kml_file, "%s<strong>Julian day</strong>: %d <br>%s",
                begin, meta->state_vectors->julDay, end);
      else if (strncmp(dbf[ii].header, "meta.state.second", 17) == 0)
        fprintf(kml_file, "%s<strong>Seconds of the day</strong>: %s <br>%s",
                begin, lf(meta->state_vectors->second), end);
      else if (strncmp(dbf[ii].header, "meta.state.vector_count", 23) == 0)
        fprintf(kml_file, "%s<strong>Vector count</strong>: %d <br>%s",
                begin, meta->state_vectors->vector_count, end);
      for (kk=0; kk<meta->state_vectors->vector_count; kk++) {
        if (strncmp(dbf[ii].header, "meta.state.vectors", 18) == 0) {
          fprintf(kml_file, "%s<strong>Time [%d]</strong>: %s <br>%s",
                  begin, kk+1, lf(meta->state_vectors->vecs[kk].time), end);
          fprintf(kml_file, "%s<strong>Position [%d} x</strong>: %s <br>%s",
                  begin, kk+1, lf(meta->state_vectors->vecs[kk].vec.pos.x),
                  end);
          fprintf(kml_file, "%s<strong>Position [%d] y</strong>: %s <br>%s",
                  begin, kk+1, lf(meta->state_vectors->vecs[kk].vec.pos.y),
                  end);
          fprintf(kml_file, "%s<strong>Position [%d] z</strong>: %s <br>%s",
                  begin, kk+1, lf(meta->state_vectors->vecs[kk].vec.pos.z),
                  end);
          fprintf(kml_file, "%s<strong>Velocity [%d] x</strong>: %s <br>%s",
                  begin, kk+1, lf(meta->state_vectors->vecs[kk].vec.vel.x),
                  end);
          fprintf(kml_file, "%s<strong>Velocity [%d] y</strong>: %s <br>%s",
                  begin, kk+1, lf(meta->state_vectors->vecs[kk].vec.vel.y),
                  end);
          fprintf(kml_file, "%s<strong>Velocity [%d] z</strong>: %s <br>%s",
                  begin, kk+1, lf(meta->state_vectors->vecs[kk].vec.vel.z),
                  end);
        }
      }
    }
  }
  for (ii=0; ii<nCols; ii++) {
    if (dbf[ii].visible == 0) {
      strcpy(begin, "<!--");
      strcpy(end, "-->\n");
    }
    else {
      strcpy(begin, "");
      strcpy(end, "\n");
    }
    // Location block
    if (meta->location) {
      if (check_meta_block("location", dbf, nCols) && !location_block) {
        fprintf(kml_file, "<br><strong>Location</strong><br>\n");
        location_block = TRUE;
      }
      if (strncmp(dbf[ii].header, 
		  "meta.location.lat_start_near_range", 34) == 0)
        fprintf(kml_file, "%s<strong>Latitude start near range</strong>: "
                "%s <br>%s", begin, lf(meta->location->lat_start_near_range),
                end);
      else if (strncmp(dbf[ii].header,
		       "meta.location.lon_start_near_range", 34) == 0)
        fprintf(kml_file, "%s<strong>Longitude start near range</strong>: "
                "%s <br>%s", begin, lf(meta->location->lon_start_near_range),
                end);
      else if (strncmp(dbf[ii].header,
		       "meta.location.lat_start_far_range", 33) == 0)
        fprintf(kml_file, "%s<strong>Latitude start far range</strong>: "
                "%s <br>%s", begin, lf(meta->location->lat_start_far_range),
                end);
      else if (strncmp(dbf[ii].header,
		       "meta.location.lon_start_far_range", 33) == 0)
        fprintf(kml_file, "%s<strong>Longitude start far range</strong>: "
                "%s <br>%s", begin, lf(meta->location->lon_start_far_range),
                end);
      else if (strncmp(dbf[ii].header,
		       "meta.location.lat_end_near_range", 32) == 0)
        fprintf(kml_file, "%s<strong>Latitude end near range</strong>: "
                "%s <br>%s", begin, lf(meta->location->lat_end_near_range),
                end);
      else if (strncmp(dbf[ii].header,
		       "meta.location.lon_end_near_range", 32) == 0)
        fprintf(kml_file, "%s<strong>Longitude end near range</strong>: "
                "%s <br>%s", begin, lf(meta->location->lon_end_near_range),
                end);
      else if (strncmp(dbf[ii].header,
		       "meta.location.lat_end_far_range", 31) == 0)
        fprintf(kml_file, "%s<strong>Latitude end far range</strong>: "
                "%s <br>%s", begin, lf(meta->location->lat_end_far_range),
                end);
      else if (strncmp(dbf[ii].header,
		       "meta.location.lon_end_far_range", 31) == 0)
        fprintf(kml_file, "%s<strong>Longitude end far range</strong>: "
                "%s <br>%s", begin, lf(meta->location->lon_end_far_range),
                end);
    }
  }
  fprintf(kml_file, "</td></tr></table>\n");
  fprintf(kml_file, "  ]]></description>\n");
  if (cfg && cfg->time) {
    ymd_date date;
    hms_time time;
    parse_DMYdate(meta->general->acquisition_date, &date, &time);
    fprintf(kml_file, "  <TimeStamp><when>%d-%02d-%02dT%02d:%02d:%.0f"
	    "</when></TimeStamp>\n",
	    date.year, date.month, date.day, time.hour, time.min, time.sec);
  }
  fprintf(kml_file, "  <name>%s</name>\n", name);
  fprintf(kml_file, "  <LookAt>\n");
  fprintf(kml_file, "    <longitude>%.10f</longitude>\n",
          meta->general->center_longitude);
  fprintf(kml_file, "    <latitude>%.10f</latitude>\n",
          meta->general->center_latitude);
  fprintf(kml_file, "    <range>%d</range>\n", cfg ? cfg->range : 400000);
  fprintf(kml_file, "  </LookAt>\n");
  fprintf(kml_file, "  <visibility>1</visibility>\n");
  fprintf(kml_file, "  <open>1</open>\n");
 
  if (cfg) { 
    // Check for valid drawing parameters
    if (strcmp_case(cfg->boundary, "POLYGON") != 0 &&
        strcmp_case(cfg->boundary, "LINE") != 0) {
      asfPrintWarning("Invalid boundary type '%s'.\n"
   		      "Will reset the boundary type to 'POLYGON'\n",
		      cfg->boundary);
      strcpy(cfg->boundary, "POLYGON");
    }
    if (strcmp_case(cfg->altitude, "RELATIVETOGROUND") != 0 &&
        strcmp_case(cfg->altitude, "CLAMPTOGROUND") != 0 &&
	strcmp_case(cfg->altitude, "ABSOLUTE") != 0) {
      asfPrintWarning("Invalid height reference '%s'.\n"
   		      "Will reset the height reference to 'clampToGround'\n",
		      cfg->altitude);
      strcpy(cfg->altitude, "clampToGround");
    }
  }

  if (cfg && strcmp_case(cfg->boundary, "LINE") == 0) {
    write_kml_style_keys_ext(kml_file, cfg);
    fprintf(kml_file, "  <LineString>\n");
    fprintf(kml_file, "    <altitudeMode>%s</altitudeMode>\n", cfg->altitude);
    fprintf(kml_file, "    <extrude>1</extrude>\n");
    fprintf(kml_file, "    <tesselate>1</tesselate>\n");
  }
  else {
    write_kml_style_keys_ext(kml_file, cfg);
    fprintf(kml_file, "  <Polygon>\n");
    fprintf(kml_file, "    <extrude>%d</extrude>\n",
	    png_filename ? 0 : 1);
    fprintf(kml_file, "    <altitudeMode>%s</altitudeMode>\n", 
            cfg ? cfg->altitude : "3000");
    fprintf(kml_file, "    <outerBoundaryIs>\n");
    fprintf(kml_file, "      <LinearRing>\n");
  }
  fprintf(kml_file, "        <coordinates>\n");

  double h = 0.0;
  double clat = meta->general->center_latitude;
  double clon = meta->general->center_longitude;
  asfPrintStatus("1) Estimated center lat, lon:  %f, %f\n", clat, clon);
  if (strcmp_case(meta->general->sensor_name, "AVNIR") == 0 &&
      strcmp_case(meta->general->mode, "1A") != 0 &&
      strcmp_case(meta->general->mode, "1B1") != 0) {
    meta_get_latLon(meta, nl/2, ns/2, h, &clat, &clon);
    asfPrintStatus("2) Calculated center lat, lon: %f, %f\n", clat, clon);
  }

  int height = cfg && cfg->height > 0 ? cfg->height : 7000;
  fprintf(kml_file, "          %.12f,%.12f,%d\n", lon_UL, lat_UL, height);
  fprintf(kml_file, "          %.12f,%.12f,%d\n", lon_LL, lat_LL, height);
  fprintf(kml_file, "          %.12f,%.12f,%d\n", lon_LR, lat_LR, height);
  fprintf(kml_file, "          %.12f,%.12f,%d\n", lon_UR, lat_UR, height);
  fprintf(kml_file, "          %.12f,%.12f,%d\n", lon_UL, lat_UL, height);
  
  fprintf(kml_file, "        </coordinates>\n");
  if (cfg && strcmp_case(cfg->boundary, "LINE") == 0) {
    fprintf(kml_file, "  </LineString>\n");
  }
  else {
    fprintf(kml_file, "      </LinearRing>\n");
    fprintf(kml_file, "    </outerBoundaryIs>\n");
    fprintf(kml_file, "  </Polygon>\n");
  }
  fprintf(kml_file, "</Placemark>\n");
  
  if (png_filename) {
    fprintf(kml_file, "<GroundOverlay>\n");
    fprintf(kml_file, "  <name>%s</name>\n", name);
    if (cfg)
      fprintf(kml_file, "  <color>%xffffff</color>\n", 
  	      (int)((100 - cfg->transparency) * 2.55 + 0.5));
    fprintf(kml_file, "  <Icon>\n");
    fprintf(kml_file, "      <href>%s</href>\n", png_filename);
    fprintf(kml_file, "      <viewBoundScale>0.75</viewBoundScale>\n");
    fprintf(kml_file, "  </Icon>\n");
    if (cfg) {
      fprintf(kml_file, "  <LatLonBox>\n");
      fprintf(kml_file, "      <north>%.4f</north>\n", cfg->north);
      fprintf(kml_file, "      <south>%.4f</south>\n", cfg->south);
      fprintf(kml_file, "      <east>%.4f</east>\n", cfg->east);
      fprintf(kml_file, "      <west>%.4f</west>\n", cfg->west);
      fprintf(kml_file, "  </LatLonBox>\n");
    }
    
    fprintf(kml_file, "</GroundOverlay>\n");
  }
  free(dbf);
}

void kml_entry_with_overlay(FILE *kml_file, meta_parameters *meta, char *name,
                            char *png_filename, char *dir)
{
  kml_entry_impl(kml_file, meta, name, png_filename, dir, NULL);
}

void kml_entry(FILE *kml_file, meta_parameters *meta, char *name)
{
  kml_entry_impl(kml_file, meta, name, NULL, NULL, NULL);
}

void kml_entry_ext(FILE *kml_file, meta_parameters *meta, char *name,
		   c2v_config *cfg)
{
  if (strlen(cfg->overlay) > 5)
    kml_entry_impl(kml_file, meta, name, cfg->overlay, NULL, cfg);
  else
    kml_entry_impl(kml_file, meta, name, NULL, NULL, cfg);
}

void kml_footer(FILE *kml_file)
{
    fprintf(kml_file, "</Document>\n");
    fprintf(kml_file, "</kml>\n");
}

void write_kml_style_keys(FILE *kml_file)
{
  write_kml_style_keys_ext(kml_file, NULL);
}

void write_kml_style_keys_ext(FILE *kml_file, c2v_config *cfg)
{
  // so all of our methods use the same "look" for the
  // boxes/lines.
  fprintf(kml_file, "  <Style>\n");
  fprintf(kml_file, "    <LineStyle>\n");
  if (cfg) {
    fprintf(kml_file, "      <color>%s</color>\n", cfg->color);
    fprintf(kml_file, "      <width>%d</width>\n", cfg->width);
  }
  else {
    fprintf(kml_file, "      <color>ffff9900</color>\n");
    fprintf(kml_file, "      <width>5</width>\n");
  }
  fprintf(kml_file, "    </LineStyle>\n");
  fprintf(kml_file, "    <PolyStyle>\n");
  fprintf(kml_file, "      <color>1fff5500</color>\n");
  fprintf(kml_file, "    </PolyStyle>\n");
  fprintf(kml_file, "  </Style>\n");
}

typedef struct
{
    double lon, lat, height;
} kml_coord_t;

typedef struct
{
    kml_coord_t *coords;
    int num_coords;
} kml_coordinates_block_t;

typedef struct
{
    char *str;
} kml_description_t;

typedef struct
{
    char *name;
    kml_description_t *description;
    kml_coordinates_block_t **coords;
    int num_coord_blocks;
} kml_placemark_t;

typedef struct
{
    kml_placemark_t **placemarks;
    int num_placemarks;
    int using_expanded_header;
    int max_coords;
    char *format;
} kml_data_t;

static int parse_kml_description_line(char *line, char **param, char **value)
{
  char *para = (char *) MALLOC(sizeof(char)*255);
  char *val = (char *) MALLOC(sizeof(char)*255);

  char *c = strstr(line, "<!--");
  char *p = strstr_case(line, "<strong>");
  char *q = strstr_case(line, "</strong>");
  char *n = strstr_case(line, "<br>");
  char *lat = strstr_case(line, "Lat</strong>"); // ignore Lat/Lon attributes
  char *lon = strstr_case(line, "Lon</strong>");

  int len, ok;
  if (p && q && n && !c && !lat && !lon) {
    p += 8; // skip past "<strong>"
    len = q-p;
    //assert(len<255);
    strncpy_safe(para, p, len+1);
    p = strchr(line, ':');
    if (p) {
      p += 2; // skips ": "
      len = n-p;
      //assert(len<255);
      strncpy_safe(val, p, len+1);
      ok=TRUE;
    }
    else {
      strcpy(para, MAGIC_UNSET_STRING);
      strcpy(val, MAGIC_UNSET_STRING);
      ok=FALSE;
    }
  }
  else {
    strcpy(para, MAGIC_UNSET_STRING);
    strcpy(val, MAGIC_UNSET_STRING);
    ok=FALSE;
  }

  *param = trim_spaces(para);
  *value = trim_spaces(val);

  FREE(para);
  FREE(val);

  return ok;
}

static char *kml_description_to_header(const char *kml_description)
{
  char *desc = STRDUP(kml_description);
  int max_header_len = strlen(kml_description)*2;
  char *header_str = MALLOC(sizeof(char)*max_header_len);
  strcpy(header_str, "");

  // go line-by-line through the kml description
  char *start = desc;
  char *end = NULL;
  do {
    end = strchr(start+1, '\n');
    if (end) {
      *end = '\0';
      char *param, *value;
      if (parse_kml_description_line(start, &param, &value)) {
        char *str = MALLOC((strlen(param)+10)*sizeof(char));
        sprintf(str, "\"%s\",", param);
        assert(strlen(header_str)+strlen(str) < max_header_len);
        strcat(header_str, str);
      }
      start = end+1;
    }
  } while (end && *start!='\0');
  free(desc);
  if (strlen(header_str)>0)
    header_str[strlen(header_str)-1]='\0';
  return header_str;
}

static char *kml_description_to_values(const char *kml_description)
{
  if (!kml_description) return STRDUP("");
  char *desc = STRDUP(kml_description);
  int max_header_len = strlen(kml_description)*2;
  char *value_str = MALLOC(sizeof(char)*max_header_len);
  strcpy(value_str, "");

  // go line-by-line through the kml description
  char *start = desc;
  char *end = NULL;
  do {
    end = strchr(start+1, '\n');
    if (end) {
      *end = '\0';
      char *param, *value;
      if (parse_kml_description_line(start, &param, &value)) {
        char *str = MALLOC((strlen(value)+10)*sizeof(char));
        sprintf(str, "\"%s\",", value);
        assert(strlen(value_str)+strlen(str) < max_header_len);
        strcat(value_str, str);
      }
      start = end+1;
    }
  } while (end && *start!='\0');
  free(desc);
  if (strlen(value_str)>0)
    value_str[strlen(value_str)-1]='\0';
  return value_str;
}

static int look_for(FILE *fp, const char *key)
{
  // scans ahead in the file until we find "key" -- case insensitive
  int i = 0;
  char ch;

  while (1) {
    ch = fgetc(fp);
    if (ch == EOF) {
      return FALSE;
    }
    else if (toupper(ch) == toupper(key[i])) {
      ++i;
      if (i==strlen(key))
        return TRUE; // found
    }
    else {
      // back to the beginning of the key
      i=0;
    }
  }
}

static char *eat_until(FILE *fp, const char *key)
{
  // scans ahead in the file until we find "key" -- case insensitive
  // store characters in a return buffer
  int len = 1024, curr_len = 0;
  char *ret = CALLOC(len, sizeof(char));

  int i = 0;
  char ch;

  while (1) {
    ch = fgetc(fp);
    ret[curr_len++] = ch;

    if (curr_len == len-1) {
      // buffer full -- allocate more
      len += 1024;
      char *old_ret = ret;
      ret = CALLOC(len, sizeof(char));
      strcpy(ret, old_ret);
      free(old_ret);
    }

    if (ch == EOF) {
      // not found... end of file.
      free(ret);
      return NULL;
    }
    else if (toupper(ch) == toupper(key[i])) {
      ++i;
      if (i==strlen(key)) {
        // found -- but cut out the actual key
        int l = strlen(ret) - strlen(key);
        assert(l>=0);
        ret[l] = '\0';

        return ret; 
      }
    }
    else {
      // back to the beginning of the key
      i=0;
    }
  }
}

static char *extract_tag(int num, const char *str,
                         const char *start_tag, const char *end_tag)
{
  int count = 0;
  char *p1;
  const char *s=str;

  do {
    p1 = strstr_case(s, start_tag);
    if (!p1) return NULL;
    s = p1+1;
  } while (++count <= num);

  char *p2 = strstr_case(p1+1, end_tag);

  if (!p1 || !p2)
    return NULL;

  p1 += strlen(start_tag);

  int len = p2 - p1 + 1;
  assert(len >= 0);
  char *ret = CALLOC(len+1, sizeof(char));
  strncpy_safe(ret, p1, len);

  return ret;
}

static kml_coordinates_block_t *parse_coordinates(const char *str)
{
  // in the first pass, figure out how many coordinates we have
  int i=0, n=0;
  int len = strlen(str);

  while (i<len) {
    // skip past whitespace
    while (isspace(str[i]) && i<len)
      ++i;

    if (isdigit(str[i]) || str[i]=='-' || str[i]=='+' || str[i]=='.')
      ++n;

    // skip past the nonwhitespace (coordinates entry)
    while (!isspace(str[i]) && i<len)
      ++i;
  }

  kml_coordinates_block_t *ret = MALLOC(sizeof(kml_coordinates_block_t));
  ret->num_coords = n;
  ret->coords = MALLOC(sizeof(kml_coord_t)*n);

  // now fill it up
  i=0;
  int c=0;
  while (i<len) {
    // skip past whitespace
    while (isspace(str[i]) && i<len)
      ++i;

    if (i>=len-1)
      break;

    // see how many commas we have
    int j=i, nc=0;
    while (!isspace(str[j])) {
      if (str[j]==',') ++nc;
      ++j;
    }
    
    int ok = TRUE;
    double lon, lat, height=0;
    if (nc==2)
      sscanf(str+i, "%lf,%lf,%lf", &lon, &lat, &height);
    else if (nc==1)
      sscanf(str+i, "%lf,%lf", &lon, &lat);
    else {
      char *buf = MALLOC(sizeof(char)*(j+1));
      strncpy_safe(buf, str+i, j);
      printf("invalid coordinate> %s\n", buf);
      free(buf);
      ok = FALSE;
    }

    if (ok) {
      assert(c < ret->num_coords);
      ret->coords[c].lon = lon;
      ret->coords[c].lat = lat;
      ret->coords[c].height = height;
      ++c;
    }

    // skip past the nonwhitespace (coordinates entry)
    while (!isspace(str[i]) && i<len)
      ++i;
  }
  
  // set actual number of coordinates, since there may have been some
  // invalid ones
  if (c < ret->num_coords)
    printf("Only found %d valid coordinate pairs, expected %d.\n",
           c, ret->num_coords);
  ret->num_coords = c;

  return ret;
}

static kml_description_t *get_description(const char *placemark)
{
  char *desc = extract_tag(0, placemark, "<description>", "</description>");

  kml_description_t *ret = MALLOC(sizeof(kml_description_t));
  ret->str = desc;
  return ret;
}

static kml_placemark_t *parse_next_placemark(FILE *fp)
{
  // first look for "<placemark>"
  int found = look_for(fp, "<placemark>");
  if (!found) // no more placemarks?
    return NULL;

  // found -- now eat characters until "</placemark>"
  char *placemark = eat_until(fp, "</placemark>");

  kml_placemark_t *ret = MALLOC(sizeof(kml_placemark_t));

  // first get description
  ret->description = get_description(placemark);
  ret->name = extract_tag(0, placemark, "<name>", "</name>");
  if (!ret->name)
    ret->name = STRDUP("Polygon");

  // count how many coordinate blocks there are
  int ncoords = 0;
  char *coords;
  do {
    coords = extract_tag(ncoords, placemark, "<coordinates>", "</coordinates>");
    if (coords) {
      ++ncoords;
      free(coords);
    }
  }
  while (coords);

  ret->coords = MALLOC(sizeof(kml_coordinates_block_t*)*ncoords);
  ret->num_coord_blocks = ncoords;

  // now extract all the coordinate blocks
  int i=0;
  do {
    coords = extract_tag(i, placemark, "<coordinates>", "</coordinates>");
    if (coords) {
      assert(i<ncoords);
      ret->coords[i] = parse_coordinates(coords);
      ++i;
      free(coords);
    }
  }
  while (coords);

  free(placemark);
  return ret;
}

static kml_data_t *parse_kml(const char *kml_file)
{
  FILE *fp = FOPEN(kml_file, "r");

  // first, count the number of placemarks
  int n=0, found;
  do {
    found = look_for(fp, "<placemark>");
    if (found)
      ++n;
  } while (found);
  fclose(fp);

  // second pass, actually read the data
  kml_data_t *ret = MALLOC(sizeof(kml_data_t));
  ret->num_placemarks = n;
  ret->placemarks = MALLOC(sizeof(kml_placemark_t*)*n);
  ret->using_expanded_header = -1;
  ret->max_coords = -1;
  ret->format = NULL;
  int i=0;

  fp = FOPEN(kml_file, "r");
  kml_placemark_t *pmk;
  do {
    pmk = parse_next_placemark(fp);
    if (pmk) {
      assert(i<n);
      ret->placemarks[i++] = pmk;
    }
  } while (pmk);

  if (i < n) {
    printf("Found only %d placemark%s, expected %d.\n", i, i==1?"":"s", n);
    ret->num_placemarks = i;
  }
  else {
    printf("Found %d placemark%s.\n", n, n==1?"":"s");
  }

  fclose(fp);

  // One final pass through the file, to find the "format" (this is something
  // that is added in if the file was generated by c2v).
  fp = FOPEN(kml_file, "r");
  char line[512];
  while (fgets(line, sizeof(line), fp)) {
    char *fmt = strstr(line, "<!-- Format:");
    if (fmt) {
      ret->format = MALLOC(sizeof(char)*strlen(fmt));
      sscanf(fmt, "<!-- Format: %s", ret->format);
      break;
    }
    if (strstr(line, "<NAME>URSA GRANULES</NAME>")) {
      ret->format = STRDUP("URSA");
      break;
    }
  }
  fclose(fp);

  return ret;
}

static void kml_data_free(kml_data_t *kml_data)
{
  if (kml_data) {
    int i,j;
    for (i=0; i<kml_data->num_placemarks; ++i) {
      kml_placemark_t *pmk = kml_data->placemarks[i];
      if (pmk) {
        free(pmk->description->str);
        if (pmk->name)
          free(pmk->name);
        for (j=0; j<pmk->num_coord_blocks; ++j) {
          kml_coordinates_block_t *coord = pmk->coords[j];
          if (coord) {
            free(coord->coords);
            free(coord);
          }
        }
        free(pmk->coords);
      }
      free(pmk);
    }
    free(kml_data->placemarks);
    if (kml_data->format)
      free(kml_data->format);
    free(kml_data);
  }
}

static char *kml_get_csv_header(kml_data_t *kml_data)
{
  assert(kml_data);

  int i,ok=TRUE;
  char *first_hdr;
  for (i=0; i<kml_data->num_placemarks; ++i) {
    kml_placemark_t *pmk = kml_data->placemarks[i];
    char *hdr;
    if (pmk->description && pmk->description->str)
      hdr = kml_description_to_header(pmk->description->str);
    else {
      hdr = STRDUP(pmk->name);
      ok=FALSE;
    }
    if (i==0) {
      first_hdr = STRDUP(hdr);
    }
    else {
      if (strcmp(hdr, first_hdr)!=0)
        ok=FALSE;
    }
    free(hdr);
  }
  if (ok) {
    // looks like the description contains a format we were able to
    // puzzle out -- so we can include some metadata in our output
    kml_data->using_expanded_header = TRUE;
    return first_hdr;
  }
  else {
    // the description fields did not work out -- use the "name"
    kml_data->using_expanded_header = FALSE;
    return STRDUP("Name");
  }
  // not reached
  assert(0);
  return NULL;
}

static char *kml_get_csv_values(kml_data_t *kml_data, int placemark_num)
{
  assert(kml_data);
  char *val=NULL;

  if (kml_data->using_expanded_header == -1)
    asfPrintError("Internal Error: Call kml_get_csv_header first!\n");

  if (placemark_num >= kml_data->num_placemarks)
    return NULL;
  kml_placemark_t *pmk = kml_data->placemarks[placemark_num];

  if (kml_data->using_expanded_header) {
    val = kml_description_to_values(pmk->description->str);
  }
  else {
    val = MALLOC(sizeof(char)*(strlen(pmk->name)+4));
    sprintf(val, "\"%s\"", pmk->name);
  }

  return val;
}

static void kml_data_dump(kml_data_t *kml_data)
{
  if (kml_data) {
    printf("Header: %s\n\n", kml_get_csv_header(kml_data));
    int i,j,k;
    for (i=0; i<kml_data->num_placemarks; ++i) {
      kml_placemark_t *pmk = kml_data->placemarks[i];
      if (pmk) {
        if (pmk->name)
          printf("Placemark: %s\n", pmk->name);
        else if (pmk->description && pmk->description->str) {
          if (strlen(pmk->description->str) > 30) {
            char buf[32];
            strncpy_safe(buf, pmk->description->str, 30);
            printf("Placemark: %s [truncated]\n", buf);
          }
          else {
            printf("Placemark: %s\n", pmk->description->str);
          }
        }

        printf("  Description: %s\n", kml_get_csv_values(kml_data, i));

        printf("  Coordinate blocks: %d\n", pmk->num_coord_blocks);
        for (j=0; j<pmk->num_coord_blocks; ++j) {
          kml_coordinates_block_t *coord = pmk->coords[j];
          if (coord) {
            printf("  Coordinate set #%d (%d points)\n", j, coord->num_coords);
            for (k=0; k<coord->num_coords; ++k) {
              kml_coord_t c = coord->coords[k];
              printf("      %6.2f,%6.2f, %f\n", c.lon, c.lat, c.height);
            }
          }
        }
      }
    }
  }
}

static char *kml_get_coords_header(kml_data_t *kml_data)
{
  int max_coords=0;
  int i,j;
  for (i=0; i<kml_data->num_placemarks; ++i) {
    kml_placemark_t *pmk = kml_data->placemarks[i];
    if (pmk) {
      for (j=0; j<pmk->num_coord_blocks; ++j) {
        kml_coordinates_block_t *coord = pmk->coords[j];
        if (coord) {
          if (coord->num_coords > max_coords)
            max_coords = coord->num_coords;
          }
      }
    }
  }
  kml_data->max_coords = max_coords;
  char *ret = MALLOC(sizeof(char)*max_coords*21);
  strcpy(ret, "");
  for (i=0; i<max_coords; ++i) {
    char str[20];
    snprintf(str, 20, "Lat%d,Lon%d,", i+1, i+1);
    strcat(ret,str);
  }
  if (strlen(ret)>0)
    ret[strlen(ret)-1]='\0';
  return ret;
}

static char *kml_get_coords_as_csv(kml_data_t *kml_data, int placemark_num,
                                   int coord_block_num)
{
  assert(kml_data);

  if (kml_data->max_coords == -1)
    asfPrintError("Internal Error: Call kml_get_coords_header first!\n");

  if (placemark_num >= kml_data->num_placemarks)
    return NULL;
  kml_placemark_t *pmk = kml_data->placemarks[placemark_num];
  assert(pmk);

  if (coord_block_num >= pmk->num_coord_blocks)
    return NULL;

  kml_coordinates_block_t *blk = pmk->coords[coord_block_num];
  assert(blk);

  char *coords=MALLOC(sizeof(char)*kml_data->max_coords*64);
  strcpy(coords, "");

  int i;
  for (i=0; i<kml_data->max_coords; ++i) {
    if (i<blk->num_coords) {
      char str[64];
      sprintf(str, "%f,%f,", blk->coords[i].lat, blk->coords[i].lon);
      strcat(coords,str);
    }
    else {
      // add empty columns -- out of data
      strcat(coords,",,");
    }
  }
  if (strlen(coords)>0)
    coords[strlen(coords)-1]='\0';
  return coords;
}

void test_kml(const char *inFile)
{
  kml_data_t *kml_data = parse_kml(inFile);
  kml_data_dump(kml_data);
  kml_data_free(kml_data);
  exit(1);
}

static void kml_open(char *filename, char **format, int *nLines,
                     int *nVertices)
{
  // try to open the kml file
  char *kml_filename=NULL;
  FILE *fp = fopen(filename, "r");
  if (!fp) {
    // failed to open, try adding ".kml" extension
    kml_filename = appendExt(filename, ".kml");
    fp = fopen(kml_filename, "r");

    if (!fp)
      asfPrintError("Couldn't open: %s\n", filename);
  }
  else
    kml_filename = STRDUP(filename);

  // read KML file to figure out the number of placemarks and maximum
  // number of vertices (and number of lines)
  char line[4096];
  char *str;
  int n = 0;
  int nPlacemarks = 0;
  int nCoordinates = 0;
  int maxVertices = 0;
  int count_on = FALSE;
  while (fgets(line, 1024, fp)) {
    str = line;
    while (isspace(*str))
      ++str;
    if (strncmp_case(str, "<COORDINATES>", 13) == 0)
      count_on = TRUE;
    if (count_on)
      ++nCoordinates;
    if (strncmp_case(str, "</COORDINATES>", 14) == 0)
      count_on = FALSE;
    if (strncmp_case(str, "</PLACEMARK>", 12) == 0) {
      ++nPlacemarks;
      nCoordinates -= 2;
      if (nCoordinates > maxVertices)
        maxVertices = nCoordinates;
      nCoordinates = 0;
    }
    ++n;
  }
  FCLOSE(fp);

  // read KML file again to fill in the array
  char *type = (char *) MALLOC(sizeof(char)*25);
  strcpy(type, "UNKNOWN");
  int ii;
  fp = FOPEN(kml_filename, "r");
  for (ii=0; ii<n; ii++) {
    fgets(line, sizeof(line), fp);
    str = line;
    while (isspace(*str))
      str++;
    if (strncmp(str, "<!-- Format:", 12) == 0)
      sscanf(str, "<!-- Format: %s", type);
    else if (strncmp_case(str, "<NAME>URSA GRANULES</NAME>", 26) == 0)
      strcpy(type, "URSA");
  }
  FCLOSE(fp);

  asfPrintStatus("Found %d placemarks in KML file\n", nPlacemarks);

  *format = type;
  *nLines = n;
  *nVertices = maxVertices;
}

// Initialize shape file
static void shape_kml_init(char *inFile, char *format, char *header,
               int vertices)
{
  // We can only deal with formats that we can positively identify.
  // Otherwise things can get pretty complicated.
  if (strcmp(format, "META") == 0) {
    // FIXME: initialization currently requires metadata structure
    asfPrintError("Conversion of META format currently not supported!\n");
    //meta_parameters *meta;
    //shape_meta_init(inFile, meta);
  }
  else if (strcmp(format, "POINT") == 0)
    shape_point_init(inFile);
  else if (strcmp(format, "POLYGON") == 0)
    shape_polygon_init(inFile, vertices);
  else if (strcmp(format, "CSV") == 0) {
    // We don't want to make any assumptions about the data types, so we
    // initialize everything as string.
    // Might want to make this more flexible later.
    csv_meta_column_t *meta_column_info;
    int ii;
    int nCols = get_number_columns(header);
    char *str;
    meta_column_info =
      (csv_meta_column_t *) MALLOC(sizeof(csv_meta_column_t)*nCols);
    for (ii=0; ii<nCols; ii++) {
      str = get_column(header, ii);
      strcpy(meta_column_info[ii].column_name, str);
      meta_column_info[ii].data_type = CSV_STRING;
      meta_column_info[ii].column_number = ii;
    }
    shape_csv_init(inFile, meta_column_info, nCols, vertices*2);
  }
  else if (strcmp(format, "AUIG") == 0)
    shape_auig_init(inFile, header);
  else if (strcmp(format, "URSA") == 0)
    shape_ursa_init(inFile, header);
  else if (strcmp(format, "GEOTIFF") == 0)
    shape_geotiff_init(inFile);
  else
    asfPrintError("Could not find a supported format.\n");
}

static int read_kml_line(char *line, char **param, char **value, int *coords)
{
  char *para = (char *) MALLOC(sizeof(char)*255);
  char *val = (char *) MALLOC(sizeof(char)*255);

  int end = strstr_case(line, "</Placemark>") != NULL;
  if (end) {
    *coords = FALSE;
    strcpy(para, MAGIC_UNSET_STRING);
    strcpy(val, MAGIC_UNSET_STRING);
  }
  else if (*coords) {
    if (strstr_case(line, "</coordinates>")) {
      strcpy(para, MAGIC_UNSET_STRING);
      strcpy(val, MAGIC_UNSET_STRING);
      *coords = FALSE;
    }
    else {
      double lon, lat;
      sscanf(line, "%lf,%lf", &lon, &lat);
      sprintf(para, "%f", lat);
      sprintf(val, "%f", lon);
      *coords = TRUE;
    }
  }
  else {
    char *c = strstr(line, "<!--");
    char *p = strstr_case(line, "<strong>");
    char *q = strstr_case(line, "</strong>");
    char *n = strstr_case(line, "<br>");
    char *lat = strstr_case(line, "Lat</strong>"); // ignore Lat/Lon attributes
    char *lon = strstr_case(line, "Lon</strong>");
    int len;
    if (p && q && n && !c && !lat && !lon) {
      p += 8; // skip past "<strong>"
      len = q-p;
      //assert(len<255);
      strncpy_safe(para, p, len+1);
      p = strchr(line, ':');
      if (p) {
        p += 2; // skips ": "
        len = n-p;
        //assert(len<255);
        strncpy_safe(val, p, len+1);
      }
      else {
        strcpy(para, MAGIC_UNSET_STRING);
        strcpy(val, MAGIC_UNSET_STRING);
      }
    }
    else if (strstr_case(line, "<coordinates>")) {
      strcpy(para, MAGIC_UNSET_STRING);
      strcpy(val, MAGIC_UNSET_STRING);
      *coords = TRUE;
    }
    else {
      strcpy(para, MAGIC_UNSET_STRING);
      strcpy(val, MAGIC_UNSET_STRING);
    }
  }

  *param = trim_spaces(para);
  *value = trim_spaces(val);

  FREE(para);
  FREE(val);

  return end;
}

static void kml2header(char *inFile, char **header)
{
  int n=1, expect_coords=FALSE, isEnd;
  char *param, *value, *header_str = (char *) MALLOC(sizeof(char)*4096);
  char str[255], line[4096];
  FILE *fp = FOPEN(inFile, "r");
  strcpy(header_str, "");
  while (fgets(line, sizeof(line), fp)) {
    isEnd = read_kml_line(line, &param, &value, &expect_coords);
    if (strcmp(param, MAGIC_UNSET_STRING) != 0 &&
        strcmp(value, MAGIC_UNSET_STRING) != 0)
    {
      if (expect_coords) {
        sprintf(str, "\"Lat%d\",\"Lon%d\",",n,n);
        ++n;
      }
      else {
        sprintf(str, "\"%s\",", param);
      }
      assert(strlen(header_str) + strlen(str) < sizeof(line));
      strcat(header_str, str);
    }
    FREE(param);
    FREE(value);
    if (isEnd)
      break;
  }
  FCLOSE(fp);
  header_str[strlen(header_str)-1] = '\0';
  *header = header_str;
}

// Convert kml to point file
int kml2point(char *inFile, char *outFile, int listFlag)
{
  int found_format = FALSE;
  float lat, lon;
  char *p, format[10], id[255];

  // Read input file
  FILE *fpIn = FOPEN(inFile, "r");
  assert(fpIn);

  // Check out whether we can find the correct format string
  // Try to write the file into the specific AUIG format only
  // when the KML file was generated by convert2vector in the first place.
  char *line = (char *) MALLOC(sizeof(char)*1023);
  while (fgets(line, 1023, fpIn)) {
    if (strstr(line, "Format: ")) {
      p = strchr(line, ':');
      p++;
      while (isspace(*p))
        p++;
      sscanf(p, "%s", format);
      if (strcmp(uc(format), "POINT") == 0) {
    found_format = TRUE;
    break;
      }
    }
  }
  if (!found_format) {
    FCLOSE(fpIn);
    asfPrintError("Found format (%s) that does not match requested format "
          "(POINT).\nPlease verify the format string at the begin "
          "of the <description> block.\n", format);
  }

  // Write file
  FILE *fpOut = FOPEN(outFile, "w");
  fprintf(fpOut, "# Format: POINT (generated by %s)", version_string("convert2vector"));
  fprintf(fpOut, "#\n");
  fprintf(fpOut, "# ID,Latitude,Longitude\n");

  // Write point information
  while (fgets(line, 1023, fpIn)) {
    // Get ID
    p = strstr(line, "<strong>ID</strong>:");
    if (p) {
      p = strchr(line, ':');
      p++;
      while (isspace(*p))
        p++;
      sscanf(p, "%s", id);
    }
    // Get latitude
    p = strstr(line, "<strong>Latitude</strong>:");
    if (p) {
      p = strchr(line, ':');
      p++;
      sscanf(p, "%f", &lat);
    }
    // Get longitude
    p = strstr(line, "<strong>Longitude</strong>:");
    if (p) {
      p = strchr(line, ':');
      p++;
      sscanf(p, "%f", &lon);
      fprintf(fpOut, "\"%s\",%f,%f\n", id, lat, lon);
    }
  }

  return 1;
}

// Convert kml to polygon file
int kml2polygon(char *inFile, char *outFile, int listFlag)
{
  int ii, vertices, found_format = FALSE;
  float lat, lon;
  char *p, str[256], format[10];

  // Read input file
  FILE *fpIn = FOPEN(inFile, "r");
  assert(fpIn);

  // Check out whether we can find the correct format string
  // Try to write the file into the specific AUIG format only
  // when the KML file was generated by convert2vector in the first place.
  char *line = (char *) MALLOC(sizeof(char)*1023);
  while (fgets(line, 1023, fpIn)) {
    if (strstr(line, "Format: ")) {
      p = strchr(line, ':');
      p++;
      while (isspace(*p))
        p++;
      sscanf(p, "%s", format);
      if (strcmp(uc(format), "POLYGON") == 0) {
        found_format = TRUE;
        break;
      }
    }
  }
  if (!found_format) {
    FCLOSE(fpIn);
    asfPrintError("Found format (%s) that does not match requested format "
                  "(POLYGON).\nPlease verify the format string at the begin "
                  "of the <description> block.\n", format);
  }

  // Write file
  FILE *fpOut = FOPEN(outFile, "w");
  fprintf(fpOut, "# Format: POLYGON (generated by %s)", version_string("convert2vector"));
  fprintf(fpOut, "#\n");
  fprintf(fpOut, "# ID,Latitude,Longitude\n");

  // Write point information
  while (fgets(line, 1023, fpIn)) {
    // Get number of vertices
    p = strstr(line, "<strong>Vertices</strong>:");
    if (p) {
      p = strchr(p, ':') + 1;
      while (isspace(*p))
        ++p;
      sscanf(p, "%d", &vertices);
    }
    for (ii=1; ii<=vertices; ii++) {
      // Get latitude
      sprintf(str, "<strong>Lat [%d]</strong>:", ii);
      p = strstr(line, str);
      if (p) {
        p = strchr(p, ':') + 1;
        while (isspace(*p))
          ++p;
        sscanf(p, "%f", &lat);
      }
      // Get longitude
      sprintf(str, "<strong>Lon [%d]</strong>:", ii);
      p = strstr(line, str);
      if (p) {
        p = strchr(p, ':') + 1;
        while (isspace(*p))
          ++p;
        sscanf(p, "%f", &lon);
        fprintf(fpOut, "%d,%f,%f\n", ii, lat, lon);
      }
    }
  }

  return 1;
}

// Convert kml to csv file
int kml2csv(char *inFile, char *outFile, int listFlag)
{
  if (listFlag) {
    asfPrintError("Not implemented.\n");
  }

  kml_data_t *kml_data = parse_kml(inFile);
  FILE *fp = FOPEN(outFile, "w");

  char *hdr = kml_get_csv_header(kml_data);
  char *coords_hdr = kml_get_coords_header(kml_data);
  fprintf(fp, "%s,%s\n", hdr, coords_hdr);
  free(coords_hdr);

  int i,j;
  for (i=0; i<kml_data->num_placemarks; ++i) {
    char *vals = kml_get_csv_values(kml_data, i);
    kml_placemark_t *pmk = kml_data->placemarks[i];
    for (j=0; j<pmk->num_coord_blocks; ++j) {
      char *coords = kml_get_coords_as_csv(kml_data, i, j);
      if (coords) {
        fprintf(fp, "%s,%s\n", vals, coords);
        FREE(coords);
      }
    }
    free(vals);
  }

  free(hdr);
  fclose(fp);

  kml_data_free(kml_data);
  return 1;
}

// Convert kml to auig file
int kml2auig(char *inFile, char *outFile, int listFlag)
{
  dbf_header_t *dbf;
  int found_format = FALSE, nCols;
  char format[10];

  // Read configuration file
  read_header_config("AUIG", &dbf, &nCols);

  // Read input file
  FILE *fpIn = FOPEN(inFile, "r");
  assert(fpIn);

  // Check out whether we can find the correct format string
  // Try to write the file into the specific AUIG format only when the KML
  // file was generated by convert2vector in the first place.
  char *p;
  char *line = (char *) MALLOC(sizeof(char)*1023);
  char *line_out = (char *) MALLOC(sizeof(char)*4096);
  while (fgets(line, 1023, fpIn)) {
    if (strstr(line, "Format: ")) {
      p = strchr(line, ':');
      p++;
      while (isspace(*p))
        p++;
      sscanf(p, "%s", format);
      if (strcmp(uc(format), "AUIG") == 0) {
        found_format = TRUE;
        break;
      }
    }
  }
  if (!found_format) {
    FCLOSE(fpIn);
    asfPrintError("Found format (%s) that does not match requested format "
                  "(AUIG).\nPlease verify the format string at the beginning "
                  "of the <description> block.\n", format);
  }

  // Fill in header line
  int ii=0, kk;
  char *header = (char *) MALLOC(sizeof(char)*4096);
  strcpy(header, "");
  while (fgets(line, 1023, fpIn)) {
    char *p = strstr(line, "<!--");
    if (p) {
      for (kk=0; kk<4; kk++)
        p++;
      ii++;
    }
    else
      p = line;
    if (strstr(p, "Sensor") && isVisible(dbf, nCols, "SENSOR"))
      strcat(header, "SENSOR,");
    else if (strstr(p, "Scene ID") && isVisible(dbf, nCols, "SCNID"))
      strcat(header, "SCNID,");
    else if (strstr(p, "DL path number") && isVisible(dbf, nCols, "DLPATHNO"))
      strcat(header, "DLPATHNO,");
    else if (strstr(p, "Used segment number") &&
             isVisible(dbf, nCols, "USESEGNO"))
      strcat(header, "USESEGNO,");
    else if (strstr(p, "Recording mode") && isVisible(dbf, nCols, "RECMODE"))
      strcat(header, "RECMODE,");
    else if (strstr(p, "Recording path") && isVisible(dbf, nCols, "RECPATH"))
      strcat(header, "RECPATH,");
    else if (strstr(p, "GSCD") && isVisible(dbf, nCols, "GSCD"))
      strcat(header, "GSCD,");
    else if (strstr(p, "OPEMD") && isVisible(dbf, nCols, "OPEMD"))
      strcat(header, "OPEMD,");
    else if (strstr(p, "Table number") && isVisible(dbf, nCols, "TBLNO"))
      strcat(header, "TBLNO,");
    else if (strstr(p, "Revolution") && isVisible(dbf, nCols, "REV"))
      strcat(header, "REV,");
    else if (strstr(p, "Path number") && isVisible(dbf, nCols, "PATHNO"))
      strcat(header, "PATHNO,");
    else if (strstr(p, "CENFLMNO") && isVisible(dbf, nCols, "CENFLMNO"))
      strcat(header, "CENFLMNO,");
    else if (strstr(p, "Proof flag") && isVisible(dbf, nCols, "PROOFFLG"))
      strcat(header, "PROOFFLG,");
    else if (strstr(p, "Steering") && isVisible(dbf, nCols, "STEERING"))
      strcat(header, "STEERING,");
    else if (strstr(p, "Orbit status") && isVisible(dbf, nCols, "ORBITSTAT"))
      strcat(header, "ORBITSTAT,");
    else if (strstr(p, "GRS line number") &&
             isVisible(dbf, nCols, "GRS_LINENO"))
      strcat(header, "GRS_LINENO,");
    else if (strstr(p, "OBS orbit number") &&
             isVisible(dbf, nCols, "OBS_ORBITNO"))
      strcat(header, "OBS_ORBITNO,");
    else if (strstr(p, "Orbit direction") && isVisible(dbf, nCols, "OBTDIR"))
      strcat(header, "OBTDIR,");
    else if (strstr(p, "Sun elevation angle") &&
             isVisible(dbf, nCols, "SUN_SUNELE"))
      strcat(header, "SUN_SUNELE,");
    else if (strstr(p, "Sun azimuth angle") &&
             isVisible(dbf, nCols, "SUN_SUNAZI"))
      strcat(header, "SUN_SUNAZI,");
    else if (strstr(p, "Scene start date") &&
             isVisible(dbf, nCols, "SCN_SDATE"))
      strcat(header, "SCN_SDATE,");
    else if (strstr(p, "Scene start time") &&
             isVisible(dbf, nCols, "SCN_STIME"))
      strcat(header, "SCN_STIME,");
    else if (strstr(p, "Scene center date") &&
             isVisible(dbf, nCols, "SCN_CDATE"))
      strcat(header, "SCN_CDATE,");
    else if (strstr(p, "Scene center time") &&
             isVisible(dbf, nCols, "SCN_CTIME"))
      strcat(header, "SCN_CTIME,");
    else if (strstr(p, "Scene center latitude") &&
             isVisible(dbf, nCols, "SCN_CLAT"))
      strcat(header, "SCN_CLAT,");
    else if (strstr(p, "Scene center longitude") &&
             isVisible(dbf, nCols, "SCN_CLON"))
      strcat(header, "SCN_CLON,");
    else if (strstr(p, "Scene left upper latitude") &&
             isVisible(dbf, nCols, "SCN_LULAT"))
      strcat(header, "SCN_LULAT,");
    else if (strstr(p, "Scene left upper longitude") &&
             isVisible(dbf, nCols, "SCN_LULON"))
      strcat(header, "SCN_LULON,");
    else if (strstr(p, "Scene right upper latitude") &&
             isVisible(dbf, nCols, "SCN_RULAT"))
      strcat(header, "SCN_RULAT,");
    else if (strstr(p, "Scene right upper longitude") &&
             isVisible(dbf, nCols, "SCN_RULON"))
      strcat(header, "SCN_RULON,");
    else if (strstr(p, "Scene left down latitude") &&
             isVisible(dbf, nCols, "SCN_LDLAT"))
      strcat(header, "SCN_LDLAT,");
    else if (strstr(p, "Scene left down longitude") &&
             isVisible(dbf, nCols, "SCN_LDLON"))
      strcat(header, "SCN_LDLON,");
    else if (strstr(p, "Scene right down latitude") &&
             isVisible(dbf, nCols, "SCN_RDLAT"))
      strcat(header, "SCN_RDLAT,");
    else if (strstr(p, "Scene right down longitude") &&
             isVisible(dbf, nCols, "SCN_RDLON"))
      strcat(header, "SCN_RDLON,");
    else if (strstr(p, "Point flag") && isVisible(dbf, nCols, "POINTFLG"))
      strcat(header, "POINTFLG,");
    else if (strstr(p, "UCUT") && isVisible(dbf, nCols, "UCUT"))
      strcat(header, "UCUT,");
    else if (strstr(p, "FCUT") && isVisible(dbf, nCols, "FCUT"))
      strcat(header, "FCUT,");
    else if (strstr(p, "RCUT") && isVisible(dbf, nCols, "RCUT"))
      strcat(header, "RCUT,");
    else if (strstr(p, "UGAIN") && isVisible(dbf, nCols, "UGAIN"))
      strcat(header, "UGAIN,");
    else if (strstr(p, "FGAIN") && isVisible(dbf, nCols, "FGAIN"))
      strcat(header, "FGAIN,");
    else if (strstr(p, "RGAIN") && isVisible(dbf, nCols, "RGAIN"))
      strcat(header, "RGAIN,");
    else if (strstr(p, "Pointing angle") && isVisible(dbf, nCols, "PNTANG"))
      strcat(header, "PNTANG,");
    else if (strstr(p, "GAINSTS") && isVisible(dbf, nCols, "GAINSTS"))
      strcat(header, "GAINSTS,");
    else if (strstr(p, "EPSSTS") && isVisible(dbf, nCols, "EPSSTS"))
      strcat(header, "EPSSTS,");
    else if (strstr(p, "REC_CLDSCENE") &&
             isVisible(dbf, nCols, "REC_CLDSCENE"))
      strcat(header, "REC_CLDSCENE,");
    else if (strstr(p, "REC_CLDDEVSCENE") &&
             isVisible(dbf, nCols, "REC_CLDDEVSCENE"))
      strcat(header, "REC_CLDDEVSCENE,");
    else if (strstr(p, "REC_ALLQLTY") && isVisible(dbf, nCols, "REC_ALLQLTY"))
      strcat(header, "REC_ALLQLTY,");
    else if (strstr(p, "REC_LINELOS") && isVisible(dbf, nCols, "REC_LINELOS"))
      strcat(header, "REC_LINELOS,");
    else if (strstr(p, "DL segment number") &&
             isVisible(dbf, nCols, "DLSEGNO"))
      strcat(header, "DLSEGNO,");
    else if (strstr(p, ">VLDS date<") && isVisible(dbf, nCols, "VLDSDATE"))
      strcat(header, "VLDSDATE,");
    else if (strstr(p, "TRNS date") && isVisible(dbf, nCols, "TRNSDATE"))
      strcat(header, "TRNSDATE,");
    else if (strstr(p, "OBSS date") && isVisible(dbf, nCols, "OBSSDATE"))
      strcat(header, "OBSSDATE,");
    else if (strstr(p, "OBSE date") && isVisible(dbf, nCols, "OBSEDATE"))
      strcat(header, "OBSEDATE,");
    else if (strstr(p, "SATCD") && isVisible(dbf, nCols, "SATCD"))
      strcat(header, "SATCD,");
    else if (strstr(p, "VLDSDEAD date") &&
             isVisible(dbf, nCols, "VLDSDEAD_DATE"))
      strcat(header, "VLDSDEAD_DATE,");
    else if (strstr(p, "VLDEDEAD date") &&
             isVisible(dbf, nCols, "VLDEDEAD_DATE"))
      strcat(header, "VLDEDEAD_DATE,");
    else if (strstr(p, "Data rate") && isVisible(dbf, nCols, "DATARATE"))
      strcat(header, "DATARATE,");
    else if (strstr(p, "File name") && isVisible(dbf, nCols, "FILENAME"))
      strcat(header, "FILENAME,");
    else if (strstr(p, "L0 status") && isVisible(dbf, nCols, "L0STATUS"))
      strcat(header, "L0STATUS,");
    else if (strstr(p, "Archive mode") && isVisible(dbf, nCols, "ARCHMODE"))
      strcat(header, "ARCHMODE,");
    else if (strstr(p, "Urgent flag") && isVisible(dbf, nCols, "URGFLG"))
      strcat(header, "URGFLG,");
    else if (strstr(p, "Semi real") && isVisible(dbf, nCols, "SEMIREAL"))
      strcat(header, "SEMIREAL,");
    else if (strstr(p, "GRS column number") &&
             isVisible(dbf, nCols, "GRS_COLNO"))
      strcat(header, "GRS_COLNO,");
    else if (strstr(p, "Scene position x") &&
             isVisible(dbf, nCols, "SCN_POSX"))
      strcat(header, "SCN_POSX,");
    else if (strstr(p, "Scene position y") &&
             isVisible(dbf, nCols, "SCN_POSY"))
      strcat(header, "SCN_POSY,");
    else if (strstr(p, "Scene position z") &&
             isVisible(dbf, nCols, "SCN_POSZ"))
      strcat(header, "SCN_POSZ,");
    else if (strstr(p, "Scene SPDX") && isVisible(dbf, nCols, "SCN_SPDX"))
      strcat(header, "SCN_SPDX,");
    else if (strstr(p, "Scene SPDY") && isVisible(dbf, nCols, "SCN_SPDY"))
      strcat(header, "SCN_SPDY,");
    else if (strstr(p, "Scene SPFZ") && isVisible(dbf, nCols, "SCN_SPDZ"))
      strcat(header, "SCN_SPDZ,");
    else if (strstr(p, "ROTCOREVISE") && isVisible(dbf, nCols, "ROTCOREVISE"))
      strcat(header, "ROTCOREVISE,");
    else if (strstr(p, "REC_CLD version") &&
             isVisible(dbf, nCols, "REC_CLDVERSION"))
      strcat(header, "REC_CLDVERSION,");
    else if (strstr(p, "REC_PIXCEL") && isVisible(dbf, nCols, "REC_PIXCEL"))
      strcat(header, "REC_PIXCEL,");
    else if (strstr(p, "REC line number") &&
             isVisible(dbf, nCols, "REC_LINENUM"))
      strcat(header, "REC_LINENUM,");
    else if (strstr(p, "PRC_BIT_PIXCEL") &&
             isVisible(dbf, nCols, "PRC_BIT_PIXCEL"))
      strcat(header, "PRC_BIT_PIXCEL,");
    else if (strstr(p, "PRC_PIXCELSETSTAT") &&
             isVisible(dbf, nCols, "PRC_PIXCELSETSTAT"))
      strcat(header, "PRC_PIXCELSETSTAT,");
    else if (strstr(p, "REC GPS DMS") &&
             isVisible(dbf, nCols, "REC_GPS_DMS"))
      strcat(header, "REC_GPS_DMS,");
    else if (strstr(p, "REC orbit number") &&
             isVisible(dbf, nCols, "REC_ORBITNUM"))
      strcat(header, "REC_ORBITNUM,");
    else if (strstr(p, "REC path date") &&
             isVisible(dbf, nCols, "REC_PATHDATE"))
      strcat(header, "REC_PATHDATE,");
    else if (strstr(p, "REC path number") &&
             isVisible(dbf, nCols, "REC_PATHNUM"))
      strcat(header, "REC_PATHNUM,");
    else if (strstr(p, "REC VLDS date") &&
             isVisible(dbf, nCols, "REC_VLDSDATE"))
      strcat(header, "REC_VLDSDATE,");
    else if (strstr(p, "REC VLDE date") &&
             isVisible(dbf, nCols, "REC_VLDEDATE"))
      strcat(header, "REC_VLDEDATE,");
    else if (strstr(p, "REC SATCNT period") &&
             isVisible(dbf, nCols, "REC_SATCNTPERIOD"))
      strcat(header, "REC_SATCNTPERIOD,");
    else if (strstr(p, "REC BASESAT time") &&
             isVisible(dbf, nCols, "REC_BASESATTIME"))
      strcat(header, "REC_BASESATTIME,");
    else if (strstr(p, "REC BASEGRD date") &&
             isVisible(dbf, nCols, "REC_BASEGRDDATE"))
      strcat(header, "REC_BASEGRDDATE,");
    else if (strstr(p, "REC UTC GPS") && isVisible(dbf, nCols, "REC_UTC_GPS"))
      strcat(header, "REC_UTC_GPS,");
    else if (strstr(p, "Browse file name") &&
             isVisible(dbf, nCols, "BRS_FILENAME"))
      strcat(header, "BRS_FILENAME,");
    else if (strstr(p, "Browse file size") &&
             isVisible(dbf, nCols, "BRS_FILESIZE"))
      strcat(header, "BRS_FILESIZE,");
    else if (strstr(p, "Browse file date") &&
             isVisible(dbf, nCols, "BRS_FILEDATE"))
      strcat(header, "BRS_FILEDATE,");
    else if (strstr(p, "TNL file name") &&
             isVisible(dbf, nCols, "TNL_FILENAME"))
      strcat(header, "TNL_FILENAME,");
    else if (strstr(p, "TNL file size") &&
             isVisible(dbf, nCols, "TNL_FILESIZE"))
      strcat(header, "TNL_FILESIZE,");
    else if (strstr(p, "TNL file date") &&
             isVisible(dbf, nCols, "TNL_FILEDATE"))
      strcat(header, "TNL_FILEDATE,");
    else if (strstr(p, "L0_EX") && isVisible(dbf, nCols, "L0_EX"))
      strcat(header, "L0_EX,");
    else if (strstr(p, "CHK flag") && isVisible(dbf, nCols, "CHK_FLG"))
      strcat(header, "CHK_FLG,");
    else if (strstr(p, "OPE status") && isVisible(dbf, nCols, "OPESTAT"))
      strcat(header, "OPESTAT,");
    else if (strstr(p, "REC red band") && isVisible(dbf, nCols, "REC RBAND"))
      strcat(header, "REC RBAND,");
    else if (strstr(p, "REC green band") && isVisible(dbf, nCols, "REC_GBAND"))
      strcat(header, "REC_GBAND,");
    else if (strstr(p, "REC blue band") && isVisible(dbf, nCols, "REC_BBAND"))
      strcat(header, "REC_BBAND,");
    else if (strstr(p, "Off nadir angle") && isVisible(dbf, nCols, "OFFNADIR"))
      strcat(header, "OFFNADIR,");
    if (strstr(line, "</td></tr></table>"))
      break;
  }
  FCLOSE(fpIn);

  // Open output file and write header line
  FILE *fpOut = FOPEN(outFile, "w");
  header[strlen(header)-1] = '\0';
  int nColumns = get_number_columns(header);
  fprintf(fpOut, "%s\n", header);
  header[strlen(header)-1] = ',';

  // Read contents
  fpIn = FOPEN(inFile, "r");
  while (fgets(line, 1023, fpIn)) {
    while (fgets(line, 1023, fpIn)) {
      if (strstr(line, "Format: AUIG"))
        break;
    };
    strcpy(line_out, "");
    while (fgets(line, 1023, fpIn)) {
      if (strstr(line, "</td></tr></table>"))
        break;
      char *test = (char *) MALLOC(sizeof(char)*255);
      for (ii=0; ii<nColumns; ii++) {
        test = get_column(header, ii);
        if (isVisible(dbf, nCols, test)) {
          char *p = strchr(line, ':');
          if (p) {
            ++p;
            while (isspace(*p))
              ++p;
            char *q = strstr(p, " <br>");
            if (q) {
              *q = ',';
              ++q;
              *q = '\0';
              strcat(line_out, p);
            }
          }
        }
      }
    }
    line_out[strlen(line_out)-1] = '\0';
    fprintf(fpOut, "%s\n", line_out);
  }

  FCLOSE(fpIn);
  FCLOSE(fpOut);

  return 1;
}

// Convert kml to shapefile, for kml files generated by this tool
// (These kml files have a lot of metadata that we can extract)
static int kml2shape_from_c2v(char *inFile, char *outFile, int listFlag)
{
  DBFHandle dbase;
  SHPHandle shape;
  char *format, *header;
  char in_line[4096];
  dbf_header_t *dbf;
  int kk, ll, nCols, n, m, nLines, nVertices, expect_coords, isEnd;
  char *param = (char *) MALLOC(sizeof(char)*255);
  char *value = (char *) MALLOC(sizeof(char)*255);
  double lat[512], lon[512];

  // Figure out the format and number of vertices
  kml_open(inFile, &format, &nLines, &nVertices);

  // Read configuration file
  if (!read_header_config(format, &dbf, &nCols))
    asfPrintError("Don't currently know anything about the requested format "
                  "(%s).\nHowever it can be added to 'header.lst' file in "
                  "the share directory\n(%s)\n", format, get_asf_share_dir());

  // Initialize shape file
  // Only known formats generated by convert2vector are supported
  kml2header(inFile, &header);
  shape_kml_init(outFile, format, header, nVertices);

  // Open shape file for some action
  open_shape(outFile, &dbase, &shape);

  kk = 0;
  n = 0;
  m = 0;
  expect_coords = FALSE;

  FILE *ifp = FOPEN(inFile, "r");
  while (fgets(in_line, 4095, ifp)) {
    isEnd = read_kml_line(in_line, &param, &value, &expect_coords);
    if (strcmp(param, MAGIC_UNSET_STRING) != 0 &&
        strcmp(value, MAGIC_UNSET_STRING) != 0)
    {
      if (expect_coords) {
        if (m<512) {
          lat[m] = atof(param);
          lon[m] = atof(value);
          ++m;
        }
      }
      else {      
        for (ll=0; ll<nCols; ll++) {
          int len = strlen(dbf[ll].header);
          if (strncmp_case(dbf[ll].header, param, len) == 0 && dbf[ll].visible)
          {
            if (dbf[ll].format == DBF_STRING)
              DBFWriteStringAttribute(dbase, kk, n, value);
            else if (dbf[ll].format == DBF_INTEGER)
              DBFWriteIntegerAttribute(dbase, kk, n, atoi(value));
            else if (dbf[ll].format == DBF_DOUBLE)
              DBFWriteDoubleAttribute(dbase, kk, n, atof(value));
            else
              asfPrintError("Unknown dbf format for %s\n", dbf[ll].header);
            n++;
          }
        }
      }
    }
    else if (isEnd) {
      ++kk;
      n=0;
      if (m>0) {
        SHPObject *shapeObj =
          SHPCreateSimpleObject(SHPT_POLYGON, m, lon, lat, NULL);
        SHPWriteObject(shape, -1, shapeObj);
        SHPDestroyObject(shapeObj);
      }
      else if (m==0) {
        printf("Invalid kml (no coordinate block), creating dummy shape.\n");
        lat[0]=lon[0]=0.0;
        SHPObject *shapeObj =
          SHPCreateSimpleObject(SHPT_POLYGON, 1, lon, lat, NULL);
        SHPWriteObject(shape, -1, shapeObj);
        SHPDestroyObject(shapeObj);
      }
      m=0;
    }
  }

  // Clean up
  FCLOSE(ifp);
  FREE(param);
  FREE(value);

  // Close shapefile
  close_shape(dbase, shape);
  write_esri_proj_file(outFile);

  return 1;
}

void kml_get_meta(kml_data_t *kml_data, int which_placemark,
                  int *num_meta_cols, char ***meta_cols)
{
  char *vals = kml_get_csv_values(kml_data, which_placemark);
  split_into_array(vals, ',', num_meta_cols, meta_cols);
  free(vals);
}

void kml_get_data(kml_data_t *kml_data, int which_placemark,
                  int which_coordinate_block,
                  int *num_data_cols, char ***data_cols)
{
  char *vals = kml_get_coords_as_csv(kml_data, which_placemark,
                                     which_coordinate_block);

  split_into_array(vals, ',', num_data_cols, data_cols);
  free(vals);
}

void print_char_array(char **arr, int nelem, char *label)
{
  printf("Array: %s (%d element%s)\n", label, nelem, nelem==1 ? "" : "s");

  int i;
  for (i=0; i<nelem; ++i)
    printf("  %d: %s\n", i, arr[i]);
}

int kml2shape(char *inFile, char *outBase, int listFlag)
{
  if (listFlag) {
    asfPrintError("Not implemented.\n");
  }

  kml_data_t *kml_data = parse_kml(inFile);

  // for kml files that we generated, we can do better with the old method,
  // since we can extract a lot of metadata.  Don't do this with the CSV
  // format, yet, since we can't have a header configuration for it, as
  // well as the META format, since the old code did not support that.
  if (kml_data->format &&
      strcmp_case(kml_data->format, "CSV") != 0 &&
      strcmp_case(kml_data->format, "META") != 0)
  {
    // this is a kml file that we generated -- can use the old method
    kml_data_free(kml_data);

    asfPrintStatus("Using kml-to-shape back-converter.\n");

    int ret = kml2shape_from_c2v(inFile, outBase, listFlag);
    return ret;
  }

  char *outFile, *ext = findExt(outBase);
  if (!ext) {
    // add .dummy extension -- shapefile lib always strips an extension
    // so we must be sure there is one there for it strip
    outFile = appendExt(outBase, ".dummy");
  }
  else {
    // already has an extension
    outFile = STRDUP(outBase);
  }

  asfPrintStatus("Using generic kml-to-shape converter.\n");

  DBFHandle dbase;
  SHPHandle shape;
  char *dbaseFile = appendExt(outBase, ".dbf");
  dbase = DBFCreate(dbaseFile);
  if (!dbase)
    asfPrintError("Could not create database file '%s'\n", dbaseFile);

  if (DBFAddField(dbase, "ID", FTString, 255, 0) == -1)
    asfPrintError("Could not add field to database file: ID\n");
  //else
    //asfPrintStatus("Added Column: ID\n");

  char *hdr = kml_get_csv_header(kml_data);
  char *coords_hdr = kml_get_coords_header(kml_data);

  int i,j,k,nmeta,ndata,nhdr,ncoord,n=0;
  char **meta_cols, **data_cols, **hdr_cols, **coords_hdr_cols;
  split_into_array(hdr, ',', &nhdr, &hdr_cols);
  //if (nhdr != 1) {
  //  asfPrintWarning("Multiple header columns found:\n");
  //  print_char_array(hdr_cols, nhdr, "HDR_COLS");
  //}

  split_into_array(coords_hdr, ',', &ncoord, &coords_hdr_cols);

  for (i=0; i<ncoord; ++i) {
    if (DBFAddField(dbase, coords_hdr_cols[i], FTDouble, 16, 7) == -1)
      asfPrintError("Could not add field to database file: %s\n",
                    coords_hdr_cols[i]);
    //else
      //asfPrintStatus("Added Column: %s\n", coords_hdr_cols[i]);
  }

  DBFClose(dbase);
  dbase = DBFOpen(dbaseFile, "r+b");

  if (ncoord>2)
    shape = SHPCreate(outFile, SHPT_POLYGON);
  else
    shape = SHPCreate(outFile, SHPT_POINT);

  for (i=0; i<kml_data->num_placemarks; ++i) {

    // get the metadata attributes, these are going to be the same
    // for all coordinate blocks in this placemark
    kml_get_meta(kml_data, i, &nmeta, &meta_cols);
    kml_placemark_t *pmk = kml_data->placemarks[i];

    for (j=0; j<pmk->num_coord_blocks; ++j) {
      kml_get_data(kml_data, i, j, &ndata, &data_cols);

      // metadata attributes
      // first is the "name" field from the KML (which we assign to "ID")
      DBFWriteStringAttribute(dbase, n, 0, pmk->name);
      // ... currently don't support all the other metadata attributes ...
      // for (k=0; k<nmeta; ++k) {
      //   DBFWriteStringAttribute(dbase, n, 0, meta_cols[k]);
      // }

      // now create the shape object, and the data attributes
      SHPObject *shapeObj=NULL;
      if (ndata==2) {
        double lon[1], lat[1];
        lat[0] = atof(data_cols[0]);
        lon[0]=  atof(data_cols[1]);
        shapeObj = SHPCreateSimpleObject(SHPT_POINT, 1, &lon[0], &lat[0],
                                         NULL);
      }
      else {
        double *write_lon = MALLOC(sizeof(double)*ndata/2);
        double *write_lat = MALLOC(sizeof(double)*ndata/2);
        int m=0;
        for (k=0; k<ndata; ++k) {
          DBFWriteDoubleAttribute(dbase, n, k+1, atof(data_cols[k]));
          if (k%2==0)
            write_lat[m] = atof(data_cols[k]);
          else
            write_lon[m++] = atof(data_cols[k]);
        }
        shapeObj = SHPCreateSimpleObject(SHPT_POLYGON, ndata/2, write_lon,
                                         write_lat, NULL);
        free(write_lat);
        free(write_lon);
      }
      SHPWriteObject(shape, -1, shapeObj);
      SHPDestroyObject(shapeObj);
      free_char_array(&data_cols, ndata);
      ++n;
    }
    free_char_array(&meta_cols, nmeta);
  }

  SHPClose(shape);
  DBFClose(dbase);
  write_esri_proj_file(outBase);

  free(hdr);
  free(coords_hdr);
  free(outFile);

  return 1;
}

int kml2ursa(char *inFile, char *outFile, int listFlag)
{
  FILE *ifp, *ofp;
  char *format, *p, *q, *data_set;
  int ii, nLines, nVertices, length;
  char in_line[4096];

  // Figure out the format and number of vertices
  kml_open(inFile, &format, &nLines, &nVertices);

  // Check the format
  if (strcmp_case(format, "URSA") != 0)
    asfPrintError("Found format (%s) that does not match requested format "
                  "(URSA).\nPlease verify that the KML file is in fact"
                  "generated the URSA system.\n", format);

  // Write the granules into the output file
  data_set = (char *) MALLOC(sizeof(char)*50);
  ifp = FOPEN(inFile, "r");
  ofp = FOPEN(outFile, "w");
  while (fgets(in_line, 4095, ifp)) {
    if (strstr(in_line, "<Placemark>")) {
      strcpy(data_set, "");
      p = strstr(in_line, "<name>");
      q = strstr(in_line, "</name>");
      if (p && q) {
        length = strlen(p) - strlen(q) - 6;
        strncpy(data_set, p+6, length);
        fprintf(ofp, "%s\n", data_set);
      }
      ii++;
    }
  }
  FCLOSE(ifp);
  FCLOSE(ofp);

  // Clean up
  FREE(data_set);

  return 1;
}
