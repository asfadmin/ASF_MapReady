#define ASF_NAME_STRING "faraday_prediction"

#define ASF_USAGE_STRING \
"   "ASF_NAME_STRING" <faraday_rotation_file> <tec_map_dir>\n"

#define ASF_DESCRIPTION_STRING \
"     This program predicts the Faraday rotation for ALOS Palsar data\n"\
"     for a given frame acquired at a particular time.\n"

#define ASF_INPUT_STRING \
"     The input file is required. The faraday rotation contains all\n"\
"     relevant information to indentify the ALOS frames with their\n"\
"     respective acquisition times. The TEC map directory directory\n"\
"     contains the global ionosphere maps, generated by the Univerisity\n"\
"     of Bern, Switzerland.\n"

#define ASF_OUTPUT_STRING \
"     The output file, also required, will be straigt ASCII file, ready\n"\
"     to be reingested into the database.\n"


#define ASF_EXAMPLES_STRING \
"     > "ASF_NAME_STRING" in_file out_file\n\n"

#include <stdio.h>
#include <asf.h>
#include <asf_meta.h>
#include <asf_sar.h>
#include <asf_license.h>
#include <asf_contact.h>

// Print minimalistic usage info & exit
static void usage(const char *name)
{
  asfPrintStatus("\n"
      "Usage:\n"
      ASF_USAGE_STRING
      "\n");
  exit(EXIT_FAILURE);
}

// Print the help info & exit
static void print_help(void)
{
  asfPrintStatus(
      "\n"
      "Tool name:\n   " ASF_NAME_STRING "\n\n"
      "Usage:\n" ASF_USAGE_STRING "\n"
      "Description:\n" ASF_DESCRIPTION_STRING "\n"
      "Input:\n" ASF_INPUT_STRING "\n"
      "Output:\n"ASF_OUTPUT_STRING "\n"
      "Examples:\n" ASF_EXAMPLES_STRING "\n"
      "Contact:\n" ASF_CONTACT_STRING "\n"
      "Version:\n   " SVN_REV " (part of " TOOL_SUITE_NAME " " MAPREADY_VERSION_STRING ")\n\n");
  exit(EXIT_SUCCESS);
}

int strmatches(const char *key, ...)
{
    va_list ap;
    char *arg = NULL;
    int found = FALSE;

    va_start(ap, key);
    do {
        arg = va_arg(ap, char *);
        if (arg) {
            if (strcmp(key, arg) == 0) {
                found = TRUE;
                break;
            }
        }
    } while (arg);

    return found;
}

double interpolate(double x, double x_hi, double y_hi, double x_lo, double y_lo)
{
  return (y_lo + (x-x_lo) * (y_hi-y_lo) / (x_hi-x_lo));
}

double lookup_tec(char *codg_file, int hour, double clat, double clon)
{
  double lat, lon1, lon2, dlat=2.5, dlon, lon, value;
  double lo_lat=0.0, hi_lat, lo_lon, hi_lon;
  double lo_lo_tec=0.0, lo_hi_tec=0.0, hi_lo_tec, hi_hi_tec;
  char line[255];

  // Get the high values
  FILE *fp = FOPEN(codg_file, "r");
  while (fgets(line, 82, fp) != NULL) {
    if (strstr(line, "START OF TEC MAP")) {
      fseek(fp, (hour-1)*32264, SEEK_CUR);
      break;
    }
  }
  while (fgets(line, 82, fp) != NULL) {
    if (strstr(line, "LAT/LON1/LON2/DLON/H"))
      sscanf(line, "%lf%lf%lf%lf", &lat, &lon1, &lon2, &dlon);
    if (fabs(lat-clat) < dlat && clat < lat) {
      hi_lat = lat;
      for (lon=lon1; lon<=lon2; lon+=dlon) {
	fscanf(fp, "%lf", &value);
	if (fabs(lon-clon) < dlon && lon < clon) {
	  lo_lon = lon;
	  hi_lo_tec = value;
	}
	if (fabs(lon-clon) < dlon && lon > clon) {
	  hi_lon = lon;
	  hi_hi_tec = value;
	}
      }
      break;
    }
  }
  FCLOSE(fp);

  // Get the low values
  fp = FOPEN(codg_file, "r");
  while (fgets(line, 82, fp) != NULL) {
    if (strstr(line, "START OF TEC MAP")) {
      fseek(fp, (hour-1)*32264, SEEK_CUR);
      break;
    }
  }
  while (fgets(line, 82, fp) != NULL) {
    if (strstr(line, "LAT/LON1/LON2/DLON/H"))
      sscanf(line, "%lf%lf%lf%lf", &lat, &lon1, &lon2, &dlon);
    if (fabs(lat-clat) < dlat && clat > lat) {
      lo_lat = lat;
      for (lon=lon1; lon<=lon2; lon+=dlon) {
	fscanf(fp, "%lf", &value);
	if (fabs(lon-clon) < dlon && lon < clon) {
	  lo_lon = lon;
	  lo_lo_tec = value;
	}
	if (fabs(lon-clon) < dlon && lon > clon) {
	  hi_lon = lon;
	  lo_hi_tec = value;
	}
      }
      break;
    }
  }
  FCLOSE(fp);

  // Interpolate values and return tec value
  double hi_tec = interpolate(clon, hi_lon, hi_hi_tec, lo_lon, hi_lo_tec);
  double lo_tec = interpolate(clon, hi_lon, lo_hi_tec, lo_lon, lo_lo_tec);
  double tec = interpolate(clat, hi_lat, hi_tec, lo_lat, lo_tec);

  return tec;
}

double lookup_reference(char *magnetic_field_file, double clat, double clon)
{
  // Read magnetic field at 350 km elevation
  // 361 lines by 179 columns
  int lat, lon;
  int lo_lat = floor(clat);
  int hi_lat = lo_lat + 1;
  int lo_lon = floor(clon);
  int hi_lon = lo_lon + 1;
  double value, lo_lo_mag, lo_hi_mag, hi_lo_mag, hi_hi_mag, lo_mag, hi_mag;
  FILE *fpMag = FOPEN(magnetic_field_file, "r");
  for (lon=-180; lon<=180; lon++)
    for (lat=89; lat>=-89; lat--) {
      fscanf(fpMag, "%lf", &value);
      if (lat == lo_lat && lon == lo_lon)
	lo_lo_mag = value;
      if (lat == lo_lat && lon == hi_lon)
	lo_hi_mag = value;
      if (lat == hi_lat && lon == lo_lon)
	hi_lo_mag = value;
      if (lat == hi_lat && lon == hi_lat)
	hi_hi_mag = value;
    }
  hi_mag = interpolate(clon, hi_lon, hi_hi_mag, lo_lon, hi_lo_mag);
  lo_mag = interpolate(clon, hi_lon, lo_hi_mag, lo_lon, lo_lo_mag);
  double mag = interpolate(clat, hi_lat, hi_mag, lo_lat, lo_mag);
  FCLOSE(fpMag);

  return mag;
} 

void sez2ijk(double south, double east, double z, double lat, double lon,
	     double *i, double *j, double *k)
{
  double t = lon*D2R;
  double l = lat*D2R;
  *i = sin(l)*cos(t)*south - sin(t)*east + cos(l)*cos(t)*z;
  *j = sin(l)*cos(t)*south + cos(t)*east + cos(l)*sin(t)*z;
  *k = -cos(l)*south + sin(l)*z;
}

void alos_pointing(int frame_id, double look_angle, 
		   double *south, double *east, double *z)
{
  double inclination = 98.16;
  double angle = cos((90-inclination)*D2R);
  int orbit = frame_id*360/7200*D2R;
  double slope_lat = angle*cos(orbit) / 
    sqrt(1 - angle*sin(orbit)*angle*sin(orbit));
  double vertical = 1/tan(look_angle*D2R);
  double mag_total = sqrt(1 + vertical*vertical);
  *east = slope_lat / mag_total;
  *south = -sqrt(1 - slope_lat*slope_lat) / mag_total;
  *z = -vertical / mag_total;
}

double faraday_prediction(int frame_id, double look_angle, int year, int day,
			  int hour, int minute, double clat, double clon, 
			  char *codg_file)
{
  // Determine total electron count for location at given time 
  // at 450 km elevation
  double fHour = (double)hour + (double)minute/60.0;
  int lo_hour = floor(fHour/2) + 1;
  int hi_hour = lo_hour + 1;
  double act_hour = fHour/2 + 1;
  double lo_tec = lookup_tec(codg_file, lo_hour, clat, clon);
  double hi_tec = lookup_tec(codg_file, hi_hour, clat, clon);
  double tec = interpolate(act_hour, hi_hour, hi_tec, lo_hour, lo_tec);
  tec /= 10.0;

  // Determine TEC at 350 km elevation
  char magnetic_field_file[512];
  sprintf(magnetic_field_file, "%s%cx_350.txt", 
	  get_asf_share_dir(), DIR_SEPARATOR);
  double mag_south = lookup_reference(magnetic_field_file, clat, clat);
  mag_south *= -1.0;
  sprintf(magnetic_field_file, "%s%cy_350.txt", 
	  get_asf_share_dir(), DIR_SEPARATOR);
  double mag_east = lookup_reference(magnetic_field_file, clat, clat);
  sprintf(magnetic_field_file, "%s%cz_350.txt", 
	  get_asf_share_dir(), DIR_SEPARATOR);
  double mag_z = lookup_reference(magnetic_field_file, clat, clat);
  mag_z *= -1.0;
  double mag_i, mag_j, mag_k;
  sez2ijk(mag_south, mag_east, mag_z, clat, clon, &mag_i, &mag_j, &mag_k);

  // Determine ALOS pointing angle
  double pt_south, pt_east, pt_z, pt_i, pt_j, pt_k; 
  alos_pointing(frame_id, look_angle, &pt_south, &pt_east, &pt_z);
  sez2ijk(pt_south, pt_east, pt_z, clat, clon, &pt_i, &pt_j, &pt_k);

  // Determine Faraday rotation 
  double nano=1e-9, tecu=1e16, K=2.37e4, frequency=1.27e9;
  double look = look_angle*D2R;
  double dot_mag_pt = mag_i*pt_i + mag_j*pt_j + mag_k*pt_k;
  double norm_mag = sqrt(mag_i*mag_i + mag_j*mag_j + mag_k*mag_k);
  double norm_pt = sqrt(pt_i*pt_i + pt_j*pt_j + pt_k*pt_k); 
  double psi = acos(dot_mag_pt / norm_mag / norm_pt);
  double omega = K/frequency/frequency*tec*tecu*nano;
  omega *= norm_mag*cos(psi)/cos(look)*R2D;
  //printf("omega: %lf\n", omega);

  return omega;
}

// Main program body.
int
main (int argc, char *argv[])
{
  char *faraday_rotation_file, *tec_map_dir, *output_file;
  char granule_name[255], data_granule_type[255];
  int frame_id, revolution, year, day, hour, minute;
  double look_angle, center_lat, center_lon, faraday_rotation;
  int currArg = 1;
  int NUM_ARGS = 2;

  // process log/quiet/license/etc options
  handle_common_asf_args(&argc, &argv, ASF_NAME_STRING);
  asfSplashScreen(argc, argv);

  if (argc<=1)
    usage(ASF_NAME_STRING);
  else if (strmatches(argv[1],"-help","--help",NULL))
    print_help();
  else if (argc<=2)
    usage(ASF_NAME_STRING);
  
  while (currArg < (argc-NUM_ARGS)) {
    char *key = argv[currArg++];
    if (strmatches(key,"-help","--help",NULL)) {
      print_help(); // doesn't return
    }
    else {
      --currArg;
      break;
    }
  }
  if ((argc-currArg) < NUM_ARGS) {
    printf("Insufficient arguments.\n");
    usage(argv[0]);
  } else if ((argc-currArg) > NUM_ARGS) {
    printf("Unknown argument: %s\n", argv[currArg]);
    usage(argv[0]);
  }
  
  faraday_rotation_file = argv[currArg];
  tec_map_dir = argv[currArg+1];
  output_file = (char *) MALLOC(sizeof(char)*(strlen(faraday_rotation_file)+9));
  sprintf(output_file, "%s_wFR.txt", faraday_rotation_file);
  char *line = (char *) MALLOC(sizeof(char)*4096);

  // Read granule information
  FILE *fpIn = FOPEN(faraday_rotation_file, "r");
  FILE *fpOut = FOPEN(output_file, "w");
  while (fgets(line, 1024, fpIn)) {
    sscanf(line, "%s %s %d %lf %d %d %d %d %d %lf %lf", granule_name, 
	   data_granule_type, &frame_id, &look_angle, &revolution, &year, &day, 
	   &hour, &minute, &center_lat, &center_lon);

    // Determine CODG file to read from
    char *codg_file = (char *) MALLOC(sizeof(char)*strlen(tec_map_dir)+20);
    sprintf(codg_file, "%s%c%d%cCODG%d0.%02dI", 
	    tec_map_dir, DIR_SEPARATOR, year, DIR_SEPARATOR, day, year-2000);
    if (!fileExists(codg_file))
      asfPrintError("CODG file (%s) does not exist.\n"
		    "Could not calculate Faraday rotation\n", codg_file);

    // Determine Faraday rotation
    faraday_rotation = 
      faraday_prediction(frame_id, look_angle, year, day, hour, minute,
			 center_lat, center_lon, codg_file);

    // Drop a line in the output file
    fprintf(fpOut, "%s\t%d\t%.1lf\t%d\t%d\t%d\t%d\t%.4lf\t%.4lf\t%.2lf\n", 
	    granule_name, frame_id, look_angle, year, day, hour, minute, 
	    center_lat, center_lon, faraday_rotation);
  }
  FCLOSE(fpIn);
  FCLOSE(fpOut);
  
  asfPrintStatus("Done.\n");
  return EXIT_SUCCESS;
}
